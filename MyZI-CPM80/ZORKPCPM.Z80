;**********************************************************************
;*                                                                    *
;*            ZIP80 - CPM VERSION                                     *
;*            Z-CODE INTERPRETER PROGRAM                              *
;*            FOR ZILOG Z80 MICROPROCESSOR                            *
;*            COPYRIGHT 1984, INFOCOM, INC.                           *
;*            COMPANY PRIVATE -- NOT FOR DISTRIBUTION                 *
;*                                                                    *
;**********************************************************************
;
;**********************************************************************
;*                                                                    *
;*            REVISION HISTORY                                        *
;*                                                                    *
;*            7/27/84  RML                                            *
;*            12/19/84 LS                                             *
;*            2/5/85   LS        (CLEAR RND FLG)                      *
;*            1/17/25  ILN       (ANSI CODES AND FORMATTING)          *
;*                                                                    *
;**********************************************************************
;
;
;**********************************************************************
;*            EQUATES                                                 *
;**********************************************************************
;
;----------------------------------------------------------------------
;SOME COMMON DEFINITIONS        
;----------------------------------------------------------------------
FALSE   EQU 00H                 ;STANDARD FALSE VALUE
TRUE    EQU 0FFH                ;STANDARD TRUE VALUE
ESC     EQU 1BH                 ;CRTL-]
CR      EQU 0DH                 ;CTRL-M
LF      EQU 0AH                 ;CTRL-J
;----------------------------------------------------------------------
;CPM EQUATES                    
;----------------------------------------------------------------------
WARM    EQU 0000H               ;WARM START IN BIOS
IOBYTE  EQU 0003H               ;I/O DEVICE BLOCK
CDISK   EQU 0004H               ;CURRENT DISK DRIVE
BDOS    EQU 0005H               ;CPM FUNCTION ENTRY POINT
LSTADR  EQU 0006H               ;LAST ADDRESS
CPMFCB  EQU 005CH               ;DEFAULT FILE CONTROL BLOCK
CPMBUF  EQU 0080H               ;DEFAULT FILE TRANSFER BUFFER
TPA     EQU 0100H               ;TRANSIENT PROGRAM AREA
;----------------------------------------------------------------------
;FILE CONTROL BLOCK OFFSETS
;----------------------------------------------------------------------
CPMDRV  EQU CPMFCB+0            ;DRIVE
CPMFNB  EQU CPMFCB+1            ;NAME STORAGE
CPMFEX  EQU CPMFCB+9            ;EXTENTION
CPMCR   EQU CPMFCB+32           ;CURRENT RECORD
CPMREC  EQU CPMFCB+33           ;RECORD NUMBER FOR RANDOM ACCESS
;----------------------------------------------------------------------
;CPM FUNCTION EQUATES
;----------------------------------------------------------------------
CRESET  EQU 0                   ;SYSTEM RESET
CCI     EQU 1                   ;CHARACTER INPUT
CCO     EQU 2                   ;CHARACTER OUTPUT
CLO     EQU 5                   ;LIST OUTPUT
CDIO    EQU 6                   ;DIRECT I/O
CPSTNG  EQU 9                   ;PRINT STRING
CRCBUF  EQU 10                  ;READ CONSOLE BUFFER
CGCONS  EQU 11                  ;GET CONSOLE STATUS
CPMRDS  EQU 13                  ;RESET DISK SYSTEM
CPMSEL  EQU 14                  ;SELECT DISK
OPEN    EQU 15                  ;ACTIVATES EXISTING FILE FOR R/W OPERATIONS
CLOSE   EQU 16                  ;INACTIVATES OPEN FILE AND RECORDS NEW FCB IN DIRECTORY
DELETE  EQU 19                  ;REMOVE EXISTING FILE FROM THE DIRECTORY
RETCUR  EQU 25                  ;RETURN CURRENT DEFAULT DISK
;
;SEQUENTIAL OPERATIONS
READS   EQU 20                  ;READ THE NEXT 128-BYTE RECORD FROM AN OPEN FILE
WRITES  EQU 21                  ;WRITE A SEQUENTIAL 128-BYTE RECORD ONTO AN OPEN FILE
;
MAKEF   EQU 22                  ;CREATE AND OPEN A NEW FILE
CPMRCD  EQU 25                  ;RETURN CURRENT DISK
;
;RANDOM OPERATIONS
READER  EQU 33                  ;READ A SPECIFIED 128-BYTE RECORD FROM AN OPEN FILE
WRITER  EQU 34                  ;WRITE A 128-BYTE RECORD TO A SPECIFIED RECORD NUMBER IN AN OPEN FILE
;
;MISC. EQUATES
CPLMAX  EQU 133                 ;MAXIMUM CHARACTERS PER LINE
;----------------------------------------------------------------------
;APPLICATION EQUATES            
;----------------------------------------------------------------------
MAXPGS  EQU 64                  ;MUST BE 64 FOR TRSN VERSIONS
ROOMG   EQU 16                  ;ROOM # (USED TO DISPLAY SHORT DESCRIPTION)
SCOREG  EQU 17                  ;SCORE
MOVESG  EQU 18                  ;NUMBER OF MOVES
ZSTAKL  EQU 224                 ;LENGTH OF THE ZSTACK IN WORDS
;
;ZCODE HEADER OFFSETS INIT VALUES
ZVERS   EQU 0                   ;VERSION BYTE
ZSWAP   EQU 1                   ;BIT FLAGS - SEE BELOW
ZID     EQU 2                   ;GAME ID WORD
ZENDLD  EQU 4                   ;START OF NON-PRELOADED ZCODE
ZSTART  EQU 6                   ;ZCODE EXECUTION ADDRESS
ZVOCAB  EQU 8                   ;START OF VOCABULARY TABLE
ZOBJEC  EQU 10                  ;START OF OBJECT TABLE
ZGLOBA  EQU 12                  ;START OF GLOBAL VARIABLE TABLE
ZPURBT  EQU 14                  ;START OF "PURE" ZCODE
ZSCRIP  EQU 16                  ;WORD FLAG FOR CONTROLLING SCRIPT FEATURE
ZSERNM  EQU 18                  ;18 THROUGH 23 ARE ASCII SERIAL NUMBER, UNIQUE TO EACH COPY
ZFWORD  EQU 24                  ;TABLE OF COMMON WORDS
ZCKLEN  EQU 26                  ;LENGTH TO USE FOR CHECKSUM
ZCKSUM  EQU 28                  ;SUM OF ALL WORDS AFTER WORD 64
;
;BIT FLAGS IN ZSWAP
ZSWAPF  EQU 1                   ;NOT USED
ZTIMEF  EQU 2                   ;IF SET, DISPLAY TIME IN STATUS LINE
ZSPLIT  EQU 4                   ;SET BY MAKDAT TO INDICATE SPLIT FILE
ZTANDY  EQU 8                   ;SET BY INTERPRETER TO DESIGNATE TANDY MACHINE
ZSTATB  EQU 10H                 ;SET BY CPM CONSOLE PROGRAM, 1 IMPLIES NO STATUS LINE
;
LPDL    EQU 400                 ;200 LEVELS OF PUSH AND POP
;
;**********************************************************************
;*            PROGRAM START                                           *
;**********************************************************************
;
        ORG 100H                ;START OF THE TPA
START:  JP CPMSTR               ;JUMP AROUND CONFIGURATION DATA
;
;**********************************************************************
;*            CONFIGURATION DATA                                      *
;**********************************************************************
CPMCPL: DB 79                   ;CHARACTERS PER LINE
CPMLPP: DB 29                   ;LINES PER PAGE EXCLUDING STATUS LINE
;FILENAME PREFIX (GAME DEPENDENT) - PADDED AT THE END WITH BLANKS (' ') TO TOTAL 8 CHARACTERS
CPMFN:  DB 'ZORK1   '
;
CPMCLF: DB 1                    ;1 FOR LF AFTER CR ON CONSOLE
CPMLLF: DB 0                    ;1 FOR LF AFTER CR ON LIST
;ORIGINAL WYSE CODES
;CPMINV: DB 80H                 ;NUMBER ADDED TO CHARACTERS FOR INVERSE VIDEO
;ALTERNATIVE VT100/ANSI CODES
CPMINV: DB 00H                  ;NUMBER ADDED TO CHARACTERS FOR INVERSE VIDEO
;
;THE FOLLOWING STRINGS HAVE A COUNT FIELD FOLLOWED BY UP TO 32 CHARACTERS
ITRMST:                         ;INIT TERMINAL, CLEAR SCREEN, LOWER LEFT,SCROLL MODE
;ORIGINAL WYSE CONTROL CODES
        ;DB 6                   ;LENGTH OF STRING
        ;DB 1EH,1AH,1BH,'=',55,32
;ALTERNATIVE VT100/ANSI CONTROL CODES
        DB 19                   ;LENGTH OF STRING
        DB ESC,'[H'             ;HOME CURSOR            = 1BH,5BH,48H
        DB ESC,'[2J'            ;CLEAR SCREEN           = 1BH,5BH,32H,4AH
        DB ESC,'[0m'            ;ALL ATTRIBUTES OFF     = 1BH,5BH,30H,6DH
        DB ESC,'[30;01H'        ;POSITION CURSOR R30,C1 = 1BH,5BH,33H,30H,3BH,30H,31H,48H
        DS 33-($-ITRMST)
RTRMST:                         ;RESET TERMINAL
;ORIGINAL WYSE CONTROL CODES
        ;DB 0                   ;LENGTH OF STRING
;ALTERNATIVE VT100/ANSI CONTROL CODES
        DB 2                    ;LENGTH OF STRING
        DB ESC,'c'              ;RESET TERMINAL         = 1BH,63H
        DS 33-($-RTRMST)
BSTLIN:                         ;BEGIN STATUS LINE STRING
;ORIGINAL WYSE CONTROL CODES
        ;DB 4                   ;LENGTH OF STRING
        ;DB 1BH,'=',32,32
;ALTERNATIVE VT100/ANSI CONTROL CODES
        DB 12                   ;LENGTH OF STRING
        DB ESC,'[01;01H'        ;POSITION CURSOR R1,C1  = 1BH,5BH,30H,31H,3BH,30H,31H,48H
        DB ESC,'[7m'            ;REVERSE ATTRIBUTE ON   = 1BH,5BH,37H,6DH
        DS 33-($-BSTLIN)
ESTLIN:                         ;END STATUS LINE STRING
;ORIGINAL WYSE CONTROL CODES
        ;DB 4                   ;LENGTH OF STRING
        ;DB 1BH,'=',55,32
;ALTERNATIVE VT100/ANSI CONTROL CODES
        DB 12                   ;LENGTH OF STRING
        DB ESC,'[0m'            ;ALL ATTRIBUTES OFF     = 1BH,5BH,30H,6DH
        DB ESC,'[30;01H'        ;POSITION CURSOR R30,C1 = 1BH,5BH,33H,30H,3BH,30H,31H,48H
        DS 33-($-ESTLIN)
PSTUPS:                         ;PRINTER SETUP STRING
        DB 0                    ;LENGTH OF STRING
        DS 33-($-PSTUPS)
;
TWODSK: DB 0                    ;SET TO 1 IF TWO DISKS ARE AVAILABLE
                 
;
        DS 200H-$               ;TO FIX THE ENTRY POINT REGARDLESS OF VARIABLE LENGTH CONFIGURATION DATA
;
;**********************************************************************
;*            CPM START - LOCATION 200H                               *
;**********************************************************************
CPMSTR: LD SP,PDL+LPDL          ;INIT MACHINE STACK
        JP BODY                 ;JUMP AROUND SUBROUTINE SECTION
;
;**********************************************************************
;*            SUBROUTINES                                             *
;**********************************************************************
ZER:    JP RESTAR
;
MEMTOP: LD HL,(LSTADR)          ;HL <= BDOS ENTRY VECTOR
        LD A,L                  ;
        CP 0FFH                 ;
        ;JP Z,MEMTP1            ;PREVIOUSLY COMMENTED OUT LINE (SCOTT)
        LD L,0FFH               ;SUBTRACT 1 BYTE
        DEC H                   ;
MEMTP1: LD A,(ZCODEP+1)         ;GET MSB OF LOW MEM STARTING POINTER
        XOR H                   ;
        AND 1                   ;
        RET NZ                  ;
        DEC H                   ;WASTE 256 MORE IF NECESSARY
        RET
;
;OPEN FILE
OPNDK1: LD (FILTYP),A           ;SAVE FILETYPE
        LD HL,CPMFCB            ;XFER DRIVE NUMBER AND FILE NAME TO FCB
        LD B,12
        CALL MOVIT
        XOR A
        LD (CPMCR),A            ;SET CURRENT RECORD=0 (SEQUENTIAL FILE)
        LD HL,0
        LD (CPMFCB+12),HL       ;SET EXTENT "EX" AND S1=0
        LD (CPMFCB+14),HL       ;SET S2 AND RECORD COUNT FOR EXTENT "EX"=0
        LD DE,CPMFCB            ;^FCB
        XOR A
        LD (CPMFCB),A           ;SELECT DEFAULT DRIVE
        LD C,OPEN               ;SELECT OPEN FUNCTION
        CALL BDOS               ;DO IT
        INC A                   ;INCREMENT DIRECTORY CODE TO TEST FOR FILE NOT FOUND
                                ;Z FLAG SET IF FILE NOT FOUND
        RET NZ                  ;IF FILE EXISTS THEN RETURN WITH Z FLAG RESET A=0
                                ;ELSE
                                ;TEST FOR TWO DISKS
        LD A,(TWODSK)           ;MULTIPLE DISKS?
        OR A
        RET Z                   ;NO ONLY 1, ZFLAG SET AND RETURN
;
;TWO DISKS
        LD A,1                  ;AUTO DISK SELECT DRIVE A
        LD (CPMFCB),A           ;SET UP THE PARAMETERS
        XOR A
        LD (CPMCR),A
        LD HL,0
        LD (CPMFCB+12),HL
        LD (CPMFCB+14),HL
        LD DE,CPMFCB
        LD C,OPEN ;TRY DRIVE 1
        CALL BDOS
        INC A
        RET NZ                  ;RETURN IF FOUND WITH ZFLAG RESET
        LD A,2                  ;ELSE AUTO DISK SELECT DRIVE B
        LD (CPMFCB),A           ;SET UP THE PARAMETERS
        XOR A
        LD (CPMCR),A
        LD HL,0
        LD (CPMFCB+12),HL
        LD (CPMFCB+14),HL
        LD DE,CPMFCB
        LD C,OPEN ;TRY DRIVE 2
        CALL BDOS
        INC A
        RET                     ;IF NOT FOUND, THEN Z WILL BE SET
;
PCSTR:  LD A,(HL)               ;PRINT STRING, GET COUNT
PCSTRL: INC HL                  ;POINT TO NEXT CHARACTER
        OR A
        RET Z                   ;DONE
        PUSH AF
        PUSH BC
        PUSH DE
        PUSH HL
        LD E,(HL)
        LD C,CDIO
        CALL BDOS
        POP HL
        POP DE
        POP BC
        POP AF
        DEC A
        JP PCSTRL
;
PCPST:  LD A,(HL)               ;PRINT PRINTER SETUP STRING, GET COUNT
PCPSTL: INC HL                  ;POINT TO NEXT CHARACTER
        OR A
        RET Z                   ;DONE
        PUSH AF
        PUSH BC
        PUSH DE
        PUSH HL
        LD E,(HL)
        LD C,CLO
        CALL BDOS
        POP HL
        POP DE
        POP BC
        POP AF
        DEC A
        JP PCPSTL
;
SETFIL: LD HL,FNDAT+1           ;APPEND TO THE FILE EXTENSION NAMES
        CALL SETFL1             ;THE GAME NAME SUFFIX
        LD HL,FNPRE+1
        CALL SETFL1
        LD HL,FNPUR+1
        CALL SETFL1
        LD HL,SRDFNM+1
SETFL1: LD DE,CPMFN
        LD B,8
        JP MOVIT
;
FNDAT:  DB 0,'........DAT'
FNPUR:  DB 0,'........PUR'
FNPRE:  DB 0,'........PRE'
SRDFNM: DB 0,'........SAV'
;
GETDSK: LD (DBUFP),HL
        CALL LFILS              ;OPEN ZORK/DAT FILE IF NOTHING OPEN
        LD L,A
        LD A,(FILTYP)
        CP 3                    ;DATA TYPE OF FILE?
        LD A,L
        JP Z,GETDK2
        LD HL,ZMEMT
        CP (HL)
        JP C,GETPRE             ;MAKE SURE ZORK/PRE IS OPEN
        SUB (HL)                ;REAL OFFSET
        CALL LFILD              ;MAKE SURE ZORK/DAT IS OPEN
        JP GETDK2
;
GETPRE: CALL LFILP              ;GET ZORK/PRE
GETDK2: LD L,A
        LD H,0
        ADD HL,HL
        ADD HL,HL               ;*4 FOR 128 BYTE BLOCKS
        CALL GTDSK1
        CALL GTDSK1
        CALL GTDSK1
GTDSK1: PUSH HL
        LD (CPMREC),HL
        XOR A
        LD (CPMREC+2),A
        LD DE,CPMFCB
        LD C,READER             ;READ RANDOM RECORD
        CALL BDOS
        OR A
        CALL NZ,ZER
        LD DE,CPMBUF
        LD HL,(DBUFP)
        LD B,128
        CALL MOVIT
        LD (DBUFP),HL
        POP HL
        INC HL                  ;INCREMENT FOR NEXT TIME
        RET
;
MOVIT:  LD A,(DE)               ;TRANSFER (D) TO (H) COUNT IN B
        LD (HL),A
        INC HL
        INC DE
        DEC B
        JP NZ,MOVIT
        RET
;
READBF: LD A,(CPMLPP)           ;LINES PER PAGE
        DEC A
        LD (MORCNT),A
        CALL FLSLIN             ;FLUSH LINE
        LD A,1
        LD (NOLPT),A            ;TURN OFF LPT DURING READ
        LD D,77                 ;D CONTAINS MAX CHARS CAN READ
        LD E,0                  ;E CONTAINS CHAR COUNT
        LD HL,(ARG1)            ;READ A BUFFER
        INC HL
READB1: CALL CIN                ;GET A CHAR
        CP 08H
        JP Z,RDBFRO
        CP 7FH
        JP Z,RDBFRO
        CP 0DH
        JP Z,RDBFCR
        CP 18
        JP Z,RDBFRT
        CP 20H
        JP C,READB1
        LD C,A
        CALL COUT
        LD A,C
        CP 'A'
        JP C,READB2
        CP 'Z'+1
        JP NC,READB2
        ADD A,'a'-'A'           ;CONVERT TO LOWER CASE
READB2: LD (HL),A
        INC HL
        INC E
        LD A,D
        CP E
        JP Z,RDBFFL
        JP READB1
;
RDBFRO: LD A,E                  ;CHECK IF 1ST CHAR
        CP 0                    ;IF SO DON'T DELETE
        JP Z,READB1             ;GO GET ANOTHER CHAR
        DEC E
        DEC HL
        CALL COUTBS
        JP READB1
;
COUTBS: LD C,08H
        CALL COUT
        LD C,20H
        CALL COUT
        LD C,08H                ;DEVINE RUBOUT
        JP COUT
;
RDBFCR: PUSH HL
        PUSH DE
        XOR A
        LD (NOLPT),A
        LD HL,(ZCODEP)
        LD DE,ZSCRIP+1
        ADD HL,DE
        LD A,(HL)
        AND 1
        JP Z,RDBFC2             ;NO LPT
        POP DE
        PUSH DE
        LD A,E
        OR A
        JP Z,RDBFC2             ;NOTHING TYPED
        LD HL,(ARG1)
        INC HL
RDBFC3: LD A,(HL)
        CP 'a'
        JP C,RDBFC4             ;NOT LOWER CASE
        SUB 'a'-'A'
RDBFC4: LD C,A
        INC HL
        CALL LPTO
        DEC E
        JP NZ,RDBFC3
RDBFC2: POP DE
        POP HL
        LD A,D
        CP E
        JP Z,RDBFC1
        INC E
        LD (HL),0DH
RDBFC1: CALL PCRLFD
        LD A,E
        RET
;
RDBFRT: PUSH DE
        PUSH HL
        LD HL,(ARG1)
        INC HL
        CALL PCRLFD
RDBFR1: LD A,E
        OR A
        JP Z,RDBFR2
        LD C,(HL)
        CALL COUT
        DEC E
        INC HL
        JP RDBFR1
;
RDBFR2: POP HL
        POP DE
        JP READB1
;
RDBFFL: CALL CIN
        CP 0DH                  ;ACCEPT <RET>
        JP Z,RDBFCR
        CP 08                   ;OR <DEL>
        JP Z,RDBFRO
        CP 7FH
        JP Z,RDBFRO
        PUSH DE
        LD E,7                  ;RING BELL, READ BUFFER FULL
        LD C,CDIO
        CALL BDOS
        POP DE
        JP RDBFFL               ;AND LOOP TIL GET WHAT WE WANT
;
CIN:    PUSH BC
        PUSH DE
        PUSH HL
CIN1:   LD E,0FFH
        LD C,CDIO               ;READ DIRECT
        CALL BDOS
        OR A
        JP Z,CIN2               ;NO CHARACTER YET
        LD HL,RDFLG
        LD (HL),0FFH            ;NOT FIRST READ ANY MORE
        POP HL
        POP DE
        POP BC
        AND 7FH
        RET
;
CIN2:   LD A,(RDFLG)
        OR A
        JP NZ,CIN1              ;NOT FIRST READ
        CALL RND
        JP CIN1
;
COUTD:  LD HL,COUTDC            ;INCREASE COUNT
        INC (HL)
        LD A,(CPMINV)           ;INVERSE VIDEO ADDER
        LD HL,STAFLG
        AND (HL)                ;ADD ONLY IF IN STATUS MODE
        ADD A,C
        LD E,A
        LD C,CDIO
        CALL BDOS
        JP POPRET
;
PCRLFD: PUSH BC
        PUSH DE
        PUSH HL
        LD E,0DH
        LD C,CDIO
        CALL BDOS
        LD A,(CPMCLF)
        OR A
        JP Z,PCRLD1             ;NO LINE FEED
        LD E,0AH
        LD C,CDIO
        CALL BDOS
PCRLD1: LD C,0DH
        CALL LPCHK
        LD HL,MORCNT
        DEC (HL)
        CALL Z,MORE
POPRET: POP HL
        POP DE
        POP BC
        RET
;
LPCHK:  PUSH BC
        PUSH DE
        PUSH HL
        LD HL,(ZCODEP)
        LD DE,ZSCRIP+1
        ADD HL,DE
        LD A,(HL)
        AND 1
        CALL NZ,LPTO
        JP POPRET
;
COUTCR: CALL LINOCR
        JP CORET
;
PCRLF:  LD C,0DH
COUT:   PUSH BC
        PUSH DE
        PUSH HL
        LD A,C
        CP 8
        JP Z,COUT1
        CP 1BH
        JP Z,CLEARS
        CP 12
        JP Z,CLEARS
        CP 0DH
        JP Z,COUTCR
        CP 20H
        JP C,CORET              ;NON PRINTING
COUT1:  LD A,(NOLPT)
        OR A
        JP NZ,COUTD
        LD A,(NCHARS)
        LD HL,CPMCPL
        CP (HL)
        CALL NC,LINOCR          ;OUTPUT LINE IF FULL
        LD A,(NCHARS)
        INC A
        LD (NCHARS),A
        LD HL,(CHRPNT)
        LD (HL),C
        INC HL
        LD (CHRPNT),HL
CORET:  POP HL
        POP DE
        POP BC
        RET
;
FLSLIN: PUSH BC                 ;FLUSH LINE
        LD A,(NCHARS)
        OR A
        JP Z,LINOTR             ;NO CHARS
        JP LINFUL               ;PRINT ALL
;
LINOUT: PUSH BC
        LD A,(NCHARS)
        OR A
        JP Z,LINOTR             ;NO CHARACTERS
        DEC A
        LD B,A
        LD A,C
        CP 0DH
        JP Z,LINFUL
        LD HL,(CHRPNT)          ;FIND LAST SPACE
        DEC HL
LINOT1: LD A,(HL)
        CP 20H
        JP Z,LINOT2             ;FOUND SPACE
        DEC HL
        DEC B
        JP P,LINOT1
LINFUL: LD HL,(CHRPNT)          ;PRINT WHOLE LINE
        LD A,(NCHARS)
        LD B,A
LINOT2: PUSH BC
        PUSH HL
        LD HL,CHARS
        LD A,B
        OR A
        JP Z,LINOT6
LINOT3: PUSH BC
        PUSH DE
        PUSH HL
        LD E,(HL)
        LD C,CDIO
        CALL BDOS
        POP HL
        PUSH HL
        LD C,(HL)
        CALL LPCHK
        POP HL
        POP DE
        INC HL
        POP BC
        DEC B
        JP NZ,LINOT3
LINOT6: POP HL
        INC HL
        POP BC
        LD A,(NCHARS)
        SUB B
        DEC A
        JP P,LINOT7
        XOR A
;
LINOT7: LD (NCHARS),A           ;CHARACTERS NOT YET PRINTED
        JP Z,LINOT5
        LD DE,CHARS
LINOT4: LD A,(HL)
        LD (DE),A
        INC HL
        INC DE
        DEC B
        JP NZ,LINOT4
LINOT5: LD HL,CHARS
        LD A,(NCHARS)
        CALL HLOFF
        LD (CHRPNT),HL
LINOTR: POP BC
        RET
;
LINOCR: CALL LINOUT
        JP PCRLFD
;
TMCHK:  LD HL,(ZCODEP)          ;RETURNS NON ZERO IF IN TIME DISPLAY MODE
        LD DE,ZSWAP
        ADD HL,DE
        LD A,(HL)
        AND ZTIMEF
        RET
;
CLEARS: RET                     ;NOT YET IMPLEMENTED
;
LPTO:   LD A,(NOLPT)
        OR A
        RET NZ                  ;SOME ITEMS DON'T GO TO LPT
        LD A,(PRFLG)
        OR A
        CALL Z,LPINIT
        PUSH BC
        PUSH DE
        PUSH HL
        LD E,C
        PUSH BC
        LD C,CLO                ;LIST OUT
        CALL BDOS
        POP BC
        LD A,C
        CP 0DH
        JP NZ,POPRET            ;NOT CR
        LD A,(CPMLLF)
        OR A
        JP Z,POPRET
        LD E,0AH
        LD C,CLO                ;OUTPUT LF IF NEEDED
        CALL BDOS
        JP POPRET
;
LPINIT: INC A
        LD (PRFLG),A
        PUSH HL
        LD HL,PSTUPS
        CALL PCPST              ;PRINTER SETUP STRING
        POP HL
        RET
;
WHOLIN: LD HL,BSTLIN
        LD A,(HL)               ;DO WE HAVE A STATUS LINE?
        OR A
        RET Z                   ;NO - RETURN
        LD A,(CSPERM)           ;SAVE DATA CLOBERED BY PRNTDC
        LD H,A
        LD A,(STBYTF)
        LD L,A
        PUSH HL
        LD HL,(ZSTWRD)
        PUSH HL
        LD HL,(MPCL)
        PUSH HL
        LD HL,(MPCH)
        PUSH HL
        LD HL,BSTLIN
        CALL PCSTR              ;POSITON TO TOP OF SCREEN
        XOR A
        LD (COUTDC),A           ;BEGINNING OF LINE
        LD A,1
        LD (NOLPT),A
        LD A,0FFH
        LD (STAFLG),A           ;STATUS LINE FLAG (ANDED WITH CPMINV ADDER)
        CALL TMCHK
        JP NZ,WHOLT
        CALL WHOLN1             ;COMMON TIME/ROOM PRINTING
        LD HL,WHOMSG            ;PRINT 'SCORE'
        CALL POSPST             ;POSITION THEN PRINT
        LD A,SCOREG
        CALL VARGET
        CALL PRNTNC
        LD C,'/'
        CALL COUT
        LD A,MOVESG
        CALL VARGET
        CALL PRNTNC
WHOLN2: LD A,(CPMCPL)
        LD B,A
        CALL CHRPOS             ;BLANK REST OF LINE
        LD HL,ESTLIN
        CALL PCSTR              ;POSITION BACK TO LOWER LEFT
        XOR A
        LD (NOLPT),A
        LD (STAFLG),A
        LD (MPCFLG),A           ;RESTORE STRING VALUES
        POP HL
        LD A,L
        LD (MPCH),A
        POP HL
        LD (MPCL),HL
        POP HL
        LD (ZSTWRD),HL
        POP HL
        LD A,H
        LD (CSPERM),A
        LD A,L
        LD (STBYTF),A
        CALL GETMOD
        RET
;
WHOLN1: LD C,' '                ;PRINT A ' '
        CALL COUT
        LD A,ROOMG              ;GET THE CURRENT ROOM NO.
        CALL VARGET
        LD A,L
        JP PRNTDC               ;PRINT THE SHORT DESCRIPTION
;
;PRINT THE TIME (HOURS)
WHOLT:  CALL WHOLN1
        LD HL,WHOTMS            ;PRINT '.......TIME' MESSAGE
        CALL POSPST
        LD A,SCOREG             ;GET HOURS IN MILITARY TIME (24 HR CLOCK)
        CALL VARGET
        LD A,L                  ;A <= HOURS
        PUSH AF                 ;SAVE HOURS
        OR A                    ;HOURS=0?
        JP NZ,WHOLT0            ;NO
        LD L,12                 ;YES - 0 HRS IS REALLY 12 HOURS
        JP WHOLT1
;
WHOLT0: CP 13                   ;COMPARE HOURS (24 HR CLOCK) WITH 13
        JP C,WHOLT1             ;IF < 13 THEN PRINT HOURS
        SUB 12                  ;ELSE A <= A-12
        LD L,A                  ;L <= ADJUSTED TIME (12 HR CLOCK)
WHOLT1: CALL PRNTNC             ;PRINT THE HOURS
        LD C,':'                ;PRINT ':'
        CALL COUT
;
;PRINT TIME (MINUTES)
        LD A,MOVESG             ;GET THE MINUTES
        CALL VARGET             ;A <= MINUTES
        CALL PNTTIM             ;PRINT THE MINUTES
        LD C,' '                ;PRINT A ' '
        CALL COUT
;
;PRINT 'AM/PM'
        LD C,'a'
        POP AF                  ;RESTORE HOURS
        CP 24                   ;24 HOURS IS AM
        JP Z,WHOLT2
        CP 12                   ;< 12 HOURS IS AM
        JP C,WHOLT2
        LD C,'p'                ;ELSE IT'S PM
WHOLT2: CALL COUT               ;PRINT 'A/P'
        LD C,'m'
        CALL COUT               ;PRINT 'M'
        JP WHOLN2
;
CHRPOS: LD A,(COUTDC)           ;SPACE UNTILE COUTDC=(B)
        CP B
        RET NC
        PUSH BC
        LD C,20H
        CALL COUT
        POP BC
        JP CHRPOS
;
POSPST: LD A,(CPMCPL)
        CP 39                   ;VERY SHORT
        JP C,POSPS1             ;DON'T PRINT WORDS
        SUB 16
        PUSH HL
        LD B,A
        CALL CHRPOS             ;SPACE OVER
        POP HL
        LD B,(HL)
POSPS2: INC HL
        LD C,(HL)
        CALL COUT
        DEC B
        JP NZ,POSPS2
        RET
;
POSPS1: SUB 8                   ;MOVE OVER 8 FROM EDGE
        LD B,A
        JP CHRPOS
;
WHOMSG: DB 7,'Score:',20H
WHOTMS: DB 6,'Time:',20H
;
MORMSG: DB '-------------More-------------',0
LMORE   EQU $-MORMSG
;
MORE:   LD A,(CPMLPP)
        OR A
        RET Z                   ;NO MORE LINE IF 0
        DEC A
        LD (HL),A
        CALL WHOLIN             ;SHOW STATUS
        LD A,1
        LD (NOLPT),A            ;DON'T SCRIPT MORE MESSAGE
        LD HL,MORMSG
        CALL MSGOUT
        CALL CIN
        LD E,0DH
        LD C,CDIO               ;CR WITHOUT LF
        CALL BDOS
        LD B,LMORE
MORE1:  PUSH BC
        LD E,20H
        LD C,CDIO
        CALL BDOS
        POP BC
        DEC B
        JP NZ,MORE1
        LD E,0DH
        LD C,CDIO
        CALL BDOS
        XOR A
        LD (NOLPT),A
        RET                     ;NOW AT BEGINNING OF CLEAR LINE
;
PNTTIM: LD DE,10
        CALL HLGEDE
        LD C,'0'
        CALL NC,COUT
        JP PRNTNC
;
;ZZZZZZZZZZZZZZZZZZZZZZZZZZZ
QUIT:   LD DE,CPMFCB
        LD C,CLOSE
        CALL BDOS
        LD HL,RTRMST
        CALL PCSTR
        LD C,CRESET
        CALL BDOS
        JP QUIT
;
RESTAR: LD DE,CPMFCB
        LD C,CLOSE
        CALL BDOS
        LD HL,RTRMST
        CALL PCSTR
        JP START
;
SAVE:   XOR A
        LD (FILTYP),A
        LD DE,CPMFCB            ;CLOSE CURRENT FCB
        LD C,CLOSE              ;SO FILE IS PROTECTED
        CALL BDOS
        CALL SRGFNM             ;GET SAVE NAME (SWAP DISKS)
        LD DE,CPMFCB            ;DELETE ANY PREVIOUS FILE 
        LD C,DELETE             ;BY THIS NAME
        CALL BDOS
        LD DE,CPMFCB            ;CREATE NEW SAVE FILE
        LD C,MAKEF
        CALL BDOS
        INC A
        JP Z,SFAIL              ;DID NOT OPEN
        LD HL,(ZCODEP)
        LD BC,ZVERS
        ADD HL,BC
        LD A,(HL)               ;STORE VERSION NUMBER
        LD (CPMBUF),A
        LD HL,(ZSTAKP)
        LD (CPMBUF+1),HL
        LD HL,CPMBUF+3
        LD DE,SRND
        LD BC,SRNDC             ;TO MAKE EXTERNALS WORK
        LD B,C
        CALL MOVIT
        LD DE,CPMFCB
        LD C,WRITES
        CALL BDOS
        OR A
        JP NZ,SFAIL             ;WRITE OUT INITIAL STUFF
        LD C,0+(((ZSTAKL*2)+127)/128)
        LD DE,ZSTACK            ;NEXT WRITE OUT STACK
SAVEA:  LD B,128
        LD HL,CPMBUF
        CALL MOVIT
        PUSH BC
        PUSH DE
        LD DE,CPMFCB
        LD C,WRITES             ;WRITE SEQ. RECORD
        CALL BDOS
        OR A
        JP NZ,SRFAIL
        POP DE
        POP BC
        DEC C
        JP NZ,SAVEA             ;ALL ZSTACK RECORDS DONE?
        LD HL,(ZCODEP)
        LD DE,ZPURBT
        ADD HL,DE
        LD C,(HL)               ;COUNT OF PAGES
        LD HL,(ZCODEP)
        EX DE,HL                ;WHERE TO START FROM
        LD B,2                  ;128 BYTE RECORDS
SAVE1:  PUSH BC
        LD HL,CPMBUF
        LD B,128
        CALL MOVIT              ;GET NEXT RECORD TO TRANSFER
        PUSH DE
        LD DE,CPMFCB
        LD C,WRITES             ;WRITE IT SEQ. TO DISK
        CALL BDOS
        POP DE
        POP BC
        OR A
        JP NZ,SFAIL             ;WRITE ERROR
        DEC B
        JP NZ,SAVE1             ;GO DO 2ND HALF OF PAGE
        LD B,2                  ;RESET FOR 2 RECORDS PER PAGE
        DEC C
        JP P,SAVE1              ;NEXT PAGE
SRCLOS: LD DE,CPMFCB
        LD C,CLOSE              ;DONE, CLOSE SAVE FILE
        CALL BDOS
        CALL SRSWPD             ;TELL PLAYER SWAP GAME DISK BACK IN
        LD C,CPMRCD             ;GET CURRENT DEFAULT DRIVE
        CALL BDOS
        PUSH AF                 ;HOLD IT A SEC
        LD C,CPMRDS             ;RESET SYSTEM FOR NEW DISK
        CALL BDOS
        POP AF                  ;RETRIEVE
        LD E,A                  ;AND RESET CORRECT DEFAULT
        LD C,CPMSEL             ;(DESTROYED BY RESET SYSTEM)
        CALL BDOS
        CALL PCRLF
        XOR A
        LD (ZPCFLG),A
        JP PREDS
;
SFAIL:  LD DE,CPMFCB
        LD C,CLOSE
        CALL BDOS
        LD DE,CPMFCB
        LD C,DELETE
        CALL BDOS
        JP SFAIL1
;
SRFAIL: LD DE,CPMFCB
        LD C,CLOSE
        CALL BDOS
SFAIL1: CALL SRSWPD
        LD C,CPMRCD             ;RETURN CURRENT DEFAULT DISK
        CALL BDOS
        PUSH AF
        LD C,CPMRDS
        CALL BDOS
        POP AF
        LD E,A
        LD C,CPMSEL             ;RESELECT DEFAULT
        CALL BDOS
        XOR A
        LD (ZPCFLG),A
        JP PREDF
;
SRGFNM: LD HL,SRMSG1
        CALL MSGOUT
        LD B,8
        LD HL,SRDFNM+1          ;FILENAME
        CALL SRGFNA             ;DISPLAY CHARS TILL HIT BLANKS
        LD HL,SRMSG3
        CALL MSGOUT
        LD B,3
        LD HL,SRDFNM+9
        CALL SRGFNA
        LD HL,SRMSG2
        CALL MSGOUT
        LD HL,0
        LD (CPMFCB+12),HL       ;CLEAR EX,S1
        LD (CPMFCB+14),HL       ;      S2,RC
        XOR A
        LD (CPMCR),A            ;      CR
        LD DE,CPMBUF
        LD A,14
        LD (DE),A
        LD C,CRCBUF             ;READ CONSOLE BUFFER
        CALL BDOS
        CALL PCRLFD
        LD C,CPMRCD             ;RETURN CURRENT DISK
        CALL BDOS
        PUSH AF
        LD C,CPMRDS             ;RESET SYSTEM
        CALL BDOS
        POP AF
        LD E,A
        LD C,CPMSEL             ;RESELECT DEFAULT
        CALL BDOS
        LD A,(CPMBUF+1)
        OR A
        JP Z,SRGDFN             ;USE DEFAULT, SKIP THIS NEXT PART
        LD B,11
        LD HL,SRDFNM
        INC HL                  ;SKIP OVER DRIVE, LEAVE AS WAS SO PLAYER NEED ONLY SPECIFY IT ONCE
SRGFM1: LD (HL),20H
        INC HL
        DEC B
        JP NZ,SRGFM1            ;FILL WITH BLANK FILE NAME
        LD B,A                  ;SAVE COUNT OF CHARACTERS
        LD HL,CPMBUF+2          ;BEG OF FILE NAME
        LD DE,SRDFNM+1          ;STORAGE FOR FILE NAME
        CP 3
        JP C,SRGFN2             ;NO DRIVE SPEC
        LD A,(CPMBUF+3)
        CP ':'                  ;DRIVE SPEC?
        JP NZ,SRGFN2            ;NONE THIS TIME
        DEC B
        DEC B
        LD A,(HL)
        AND 0FH                 ;DRIVE NUMBER
        LD (SRDFNM),A
        INC HL
        INC HL                  ;POINTER PAST DRIVE SPEC
SRGFN2: DEC B
        JP M,SRGDFN             ;FILE NAME NOW DEFAULT
        LD A,(HL)
        CALL UPPER
        INC HL
        CP '.'
        JP Z,SRGFN3             ;EXTENTION
        LD (DE),A
        INC DE
        JP SRGFN2
;
SRGFNA: LD A,(HL)
        CP ' '
        JP Z,SRGFNB
        LD C,A
        PUSH BC
        PUSH DE
        PUSH HL
        LD E,(HL)
        LD C,CDIO
        CALL BDOS
        POP HL
        PUSH HL
        CALL MSGCRC             ;SEND LF IF NECESSARY
        POP HL
        POP DE
        POP BC
        CALL LPCHK
SRGFNB: INC HL
        DEC B
        JP NZ,SRGFNA
        RET
;
UPPER:  CP 'a'
        RET C
        CP 'z'+1
        RET NC
        SUB 'a'-'A'
        RET
;
SRGFN3: LD DE,SRDFNM+9
        LD A,B
        AND 3                   ;MAX OF 3 CHARACTERS
        LD B,A
        JP SRGFN2
;
SRGDFN: LD DE,SRDFNM            ;DEFAULT FILE NAME
        LD HL,CPMFCB
        LD B,12
        JP MOVIT
;
SRSWPD: LD HL,LFILDG
MSGRES: CALL MSGOUT             ;MESSAGE THEN RESPONSE
        CALL CIN                ;WAIT FOR CHARACTER
        LD HL,CRMSG
        JP MSGOUT
;
CRMSG:  DB 0DH,0
;
LFILDG: DB 'Load Game Disk if it was removed.',0DH
        DB 'Type <ENTER> to continue >',0
LFILDM: DB 'Load Disk 2, type <ENTER> to continue >',0
LFILPM: DB 'Load Disk 1, type <ENTER> to continue >',0
LFILGM: DB 'Load Game Disk, type <ENTER> to continue >',0
;
SRMSG1: DB 'Load SAVE disk then enter file name.',0DH
        DB '(default file name is ',0
;
SRMSG2: DB ').',0DH
        DB 'Type <ENTER> to continue  > ',0
;
SRMSG3: DB '.',0
;
MSGOUT: LD C,(HL)
        LD A,(HL)
        OR A
        RET Z
        PUSH BC
        PUSH DE
        PUSH HL
        LD E,(HL)
        LD C,CDIO
        CALL BDOS
        POP HL
        PUSH HL
        CALL MSGCRC
        POP HL
        POP DE
        POP BC
        CALL LPCHK
        INC HL
        JP MSGOUT
;
MSGCRC: LD A,(CPMCLF)
        OR A
        RET Z                   ;NO LF AFTER CR
        LD A,(HL)
        CP 0DH
        RET NZ                  ;NOT CR
        LD E,0AH                ;PRINT A LF
        LD C,CDIO
        CALL BDOS
        RET
;
RESTOR: XOR A
        LD (FILTYP),A
        LD DE,CPMFCB
        LD C,CLOSE
        CALL BDOS
        CALL SRGFNM
        LD DE,CPMFCB
        LD C,OPEN
        CALL BDOS
        INC A
        JP Z,SRFAIL
        LD DE,CPMFCB
        LD C,READS
        CALL BDOS
        OR A
        JP NZ,SRFAIL
        LD HL,(ZCODEP)
        LD DE,ZVERS
        ADD HL,DE
        LD A,(CPMBUF)
        CP (HL)
        JP NZ,SRFAIL            ;VERSIONS DIFFER
        LD HL,(CPMBUF+1)
        LD (ZSTAKP),HL          ;STACK POINTER
        LD DE,CPMBUF+3
        LD HL,SRND
        LD BC,SRNDC             ;TO MAKE EXTERNALS WORK
        LD B,C
        CALL MOVIT              ;RESTORE RANDOM DATA
        LD C,0+(((ZSTAKL*2)-1)/128) ;ONE TOO FEW
        LD HL,ZSTACK            ;NEXT WRITE OUT STACK
RESTA:  PUSH BC
        PUSH HL
        LD DE,CPMFCB
        LD C,READS
        CALL BDOS
        POP HL
        POP BC
        OR A
        JP NZ,SRFAIL
        LD DE,CPMBUF
        LD B,128
        CALL MOVIT
        DEC C
        JP NZ,RESTA
        PUSH HL                 ;READ LAST BLOCK
        LD DE,CPMFCB
        LD C,READS
        CALL BDOS
        POP HL
        OR A
        JP NZ,SRFAIL
        LD DE,CPMBUF
        LD B,0+((ZSTAKL*2)-((((ZSTAKL*2)-1)/128)*128))
        CALL MOVIT
        LD HL,(ZCODEP)
        LD DE,ZSCRIP+1
        ADD HL,DE
        LD (SCPLOC),HL          ;LOCATION OF SCRIPT FLAG
        LD A,(HL)
        AND 1                   ;ISOLATE SCRIPT BIT
        LD (SCPVAL),A           ;AND SAVE
        LD HL,(ZCODEP)
        LD DE,ZPURBT
        ADD HL,DE
        LD C,(HL)
        LD HL,(ZCODEP)          ;POINTER TO BEGINNING OF DATA
        LD B,2                  ;128 BYTE RECORDS
REST1:  PUSH BC
        PUSH HL
        LD DE,CPMFCB
        LD C,READS
        CALL BDOS
        POP HL
        POP BC
        OR A
        JP NZ,RESTAR
        LD DE,CPMBUF
        PUSH BC
        LD B,128
        CALL MOVIT
        POP BC
        DEC B
        JP NZ,REST1
        LD B,2
        DEC C
        JP P,REST1
        LD HL,(SCPLOC)
        LD A,(HL)
        AND 0FEH                ;CLEAR SCRIPT BIT
        PUSH HL
        LD HL,SCPVAL
        OR (HL)                 ;OR IN VALUE FROM MEMORY
        POP HL
        LD (HL),A
        JP SRCLOS               ;ALL DONE
;
LFILS:  PUSH AF
        LD A,(FILTYP)
        CP 3                    ;.DAT FILE ALREADY OPEN?
        JP Z,LFILR              ;YES - RETURN
        OR A                    ;NO - SOME OTHER TYPE OPEN?
        JP NZ,LFILR             ;YES - RETURN
LFILS1: LD DE,FNDAT             ;NO - ^ DATA FILE NAME
        LD A,3                  ;OPEN TYPE 3
        CALL OPNDK1             ;TRY TO OPEN FILE
        JP NZ,LFILR             ;OPEN .DAT FILE COMPLETE?
                                ;YES - RETURN
        LD A,(TWODSK)           ;CHECK IF 1 OR 2 DISKS FOR GAME
        CP 1                    ;IF = 1 THEN 2 DISKS
        JP Z,LFILF              ;SO GO TRY OTHER TYPE FILES
        LD HL,LFILGM            ;ELSE ASK FOR CORRECT DISK
        CALL MSGRES
        JP LFILS1               ;AND TRY AGAIN
LFILF:  XOR A                   ;NO - SET FILTYP=0
        LD (FILTYP),A           ;OPEN FAILED TRY OTHER TYPE
        JP LFILR
;
LFILD:  PUSH AF
        LD A,(FILTYP)
        CP 2                    ;.PUR FILE ALREADY OPEN?
        JP Z,LFILR              ;YES.ALREADY OPEN
        CALL LFILC              ;CLOSE EXISTING FILE IF ANY
LFILD1: LD DE,FNPUR
        LD A,2
        CALL OPNDK1             ;TRY TO OPEN PURELOAD FILE
        JP NZ,LFILR             ;OPEN OK
        LD HL,LFILDM
        CALL MSGRES             ;ASK TO LOAD DISK
        JP LFILD1               ;TRY AGAIN
;
LFILP:  PUSH AF
        LD A,(FILTYP)
        CP 1                    ;PRELOAD TYPE?
        JP Z,LFILR              ;OPEN
        CALL LFILC
LFILP1: LD DE,FNPRE
        LD A,1
        CALL OPNDK1
        JP NZ,LFILR             ;OPEN OK
        LD HL,LFILPM
        CALL MSGRES             ;LOAD PROPER DISK
        JP LFILP1
;
LFILR:  POP AF
        RET
;
LFILC:  OR A
        RET Z                   ;NONE OPEN
        LD DE,CPMFCB
        LD C,CLOSE
        CALL BDOS
        XOR A
        LD (FILTYP),A
        RET
;
;DATA
STAFLG: DB 0                    ;0FFH WHEN IN STATUS LINE MODE
COUTDC: DB 0                    ;CHARACTER COUNT UNDER STATUS LINE
RDFLG:  DB 0                    ;0 FOR FIRST READ
PRFLG:  DB 0                    ;0 FOR FIRST PRINT
SCPLOC: DW 0                    ;SCRIPT LOCATION
SCPVAL: DB 0                    ;SCRIPT VALUE
DBUFP:  DW 0                    ;DSK POINTER
NCHARS: DB 0
CHARS:  DS CPLMAX
CHRPNT: DW CHARS

FILTYP: DB 0                    ;0 FOR NONE, 1 FOR PRE, 2 FOR PUR, 3 FOR DAT
MORCNT: DB 23

;(PUT IN CODE SEGMENT TO PRESERVE COMMON ZORKBODY)
PDL:    DS LPDL                 ;CONTROL STACK
ZSTAKP: DW ZSTACK+(2*ZSTAKL)    ;POINTER TO CURRENT ZSTACK
ZSTACK: DS ZSTAKL*2             ;ZSTACK
PGTBL:  DS MAXPGS               ;PAGE NUMBER, 0 ALWAYS IN MEMORY, THUS 0=FREE
PGTBLF: DS MAXPGS               ;NEXT LINK POINTER, 0FFH IMPLIES END POINT
PGTBLB: DS MAXPGS               ;PREVIOUS LINK POINTER
PGTFD   EQU PGTBLF-PGTBL
PGTBD   EQU PGTBLB-PGTBL
;
VRS:    DB 0DH,'UPDATED 2.5.85',0DH,0
VRLINE: DB 0DH,'VERSION C',0DH,0
;
;**********************************************************************
;*            WARMSTART ENTRY                                         *
;**********************************************************************
;
;MAIN BODY OF CODE STARTS HERE
;
BODY:   XOR A
        LD (ZPCFLG),A           ;DISABLE TIME IN STATUS LINE, NO SPLIT FILE, NOT TANDY
        LD (MPCFLG),A           ;NO VALID MEMORY IN FROM DISK (MPCPNT NOT VALID)
        LD (PGTOP),A            ;SET TOP OF LIST PAGE
        LD C,RETCUR             ;GET CURRENT DEFAULT DRIVE
        CALL BDOS               ;RETS IN A
        LD E,A                  ;SET DEFAULT DRIVE
        LD C,CPMSEL             ;THIS SEEMS REDUNDENT BUT THE MACHINE IS NOT 
        CALL BDOS               ;RECOGNIZING RESETS FROM BOOT DRIVE DONE BEFORE STARTING THE GAME
;
;INITIALIZE ZSTACK
;
        LD A,1
        LD (ZSTAKC),A           ;INITIALIZE ZSTACK POSITION COUNTER
        LD HL,ZSTACK+(2*ZSTAKL)
        LD (ZSTAKP),HL          ;SAVE THE LOCATION OF THE BOTTOM OF ZSTACK IN ZSTACK POINTER
;
;INITIALIZE PAGE TABLES
;
        LD DE,PGTBL             ;DE ^  TOP OF PAGE TABLE
        LD BC,0+(MAXPGS*256)    ;FOR NUMBER OF PAGES (IN B)
;
;INITIALIZE PGTBL
START1: XOR A
        LD (DE),A               ;(PGTBL+PAGE NUMBER) <= 0
                                ;FREE THE PAGE (NO PAGE IN MEMORY)
;
        LD HL,PGTFD             ;HL <= MAXIMUM NUMBER OF PAGES
                                ;USED AS AN OFFSET INTO PGTBLF
;
;INITIALIZE FOWARD POINTER
        ADD HL,DE               ;HL ^ PAGE FORWARD POINTER TABLE SLOT
        LD (HL),C               ;SAVE CURRENT POINTER
        INC (HL)                ;ADD 1 TO MAKE IT A FORWARD POINTER
;
;INITIALIZE PREVIOUS POINTER
        LD HL,PGTBD             ;HL ^ PAGE PREVIOUS POINTER TABLE BASE ADDRESS
        ADD HL,DE               ;ADD OFFSET
        LD (HL),C               ;SAVE CURRENT POINTER
        DEC (HL)                ;SUBTRACT 1 TO MAKE IT A PREVIOUS POINTER
;
;UPDATE
        INC C                   ;NEXT PAGE
        INC DE                  ;NEXT SLOT IN TABLES
;
;TEST LOOP FOR DONE
        DEC B                   ;DECREMENT NUMBER OF SLOTS REMAINING
        JP NZ,START1            ;>0? YES - CONTINUE LOOPING
;
;CORRECT FOR NO FORWARD POINTER FOR LAST PAGE
        LD HL,PGTFD-1
        ADD HL,DE
        LD (HL),0FFH
;
;SET BOTTOM PAGE NO.
        LD A,MAXPGS-1
        LD (PGBOT),A
;
;COMPUTE ZCODE STARTING ADDRESSS
        LD HL,LMEMRY            ;POINT HL PAST ZIP
        LD DE,0FFH              ;ADJUST ADDRESS TO A PAGE BOUNDRY
        ADD HL,DE
        LD L,0
        LD (ZCODEP),HL          ;SAVE ZCODE STARTING ADDRESS
;
;SET UP FILE NAMES FOR DAT, PRE, PUR AND SAV
        CALL SETFIL             ;APPEND GAME NAME PREFIX TO FILE NAME EXTENSIONS
;
;RESET FILE TYPE
        XOR A                   ;RESET FILTYP
        LD (FILTYP),A
;
;INITIALIZE TERMINAL
        LD HL,ITRMST            ;POINT TO TERMINAL INITIALIZATION STRING
        CALL PCSTR              ;FOR HOME, CLEAR SCREEN AND PRINT IT
;
;INITIALIZE TERMINAL RELATED COUNTERS
        LD A,(CPMLPP)           ;INITIALIZE LINES/PAGE (EXCLUDING STATUS LINE)
        DEC A                   ;COUNTER (MORCNT)=(CPMLPP)-1
        LD (MORCNT),A           ;WHICH TELLS THE PROGRAM WHEN TO PRINT ....MORE....
        XOR A                   ;A<=0 
        LD (NCHARS),A           ;RESET (NCHARS)
        LD HL,CHARS             ;SET UP CHARACTERS/LINE
        LD (CHRPNT),HL
;
;GET THE FIRST SECTOR OF ZCODE
        LD HL,(ZCODEP)          ;^ TOP OF ZCODE BUFFER
        XOR A
        CALL GETDSK             ;READ IN FIRST SECTION
;
;EXTRACT GAME DATA FROM ZCODE HEADER
        LD HL,(ZCODEP)          ;HL ^ TOP OF ZCODE BUFFER
        LD DE,ZENDLD            ;DE <= OFFSET TO NON-PRELOADED ZCODE
        ADD HL,DE               ;HL ^ START OF NON-PRELOADED ZCODE
        LD D,(HL)               ;GET MSB OF ENDLOAD POINTER
        INC HL                  ;ADD 1
        LD E,(HL)               ;GET LSB OF ENDLOAD POINTER
        LD HL,200H              ;HL <= 256
        ADD HL,DE               ;HL <= ENDLOAD POINTER + 200H
        LD A,H                  ;A <= MSB
        AND 0FEH                ;
        LD H,A                  ;
        LD L,0                  ;
        DEC HL                  ;ALL THIS TO GET TO BLOCK BOUNDRY
        EX DE,HL                ;DE <= CORRECTED ENDLOAD POINTER
        LD BC,ZENDLD            ;BC <= OFFSET TO NON-PRELOADED ZCODE
        LD HL,(ZCODEP)          ;HL ^ TOP OF ZCODE BUFFER
        ADD HL,BC               ;HL ^ START OF NON-PRELOADED ZCODE
        LD (HL),D               ;SAVE MSB OF CORRECTED ENDLOAD POINTER
        INC HL
        LD (HL),E               ;SAVE LSB OF CORRECTED ENDLOAD POINTER
        LD HL,(ZCODEP)          ;HL ^ TOP OF ZCODE BUFFER
        PUSH DE                 ;SAVE CORRECTED ENDLOAD POINTER ON STACK
        ADD HL,DE               ;HL ^ END OF PRELOAD
        EX DE,HL                ;DE ^ END OF PRELOAD
        CALL MEMTOP             ;DETERMINE WHERE THE TOP OF MEMORY IS (IN HL)
        EX DE,HL                ;DE <= TOP OF MEMORY, HL <= END OF THE PRELOAD
        CALL HLGEDE             ;CARRY FLAG SET IF HL G.E. DE
        POP DE                  ;RESTORE CORRECTED ENDLOAD POINTER
        CALL C,ZER              ;NO ROOM FOR ANY BUFFERS
        LD A,D
        RRCA
        AND 7FH
        LD D,A                  ;NUMBER OF PAGES IN REST OF THE PRELOAD
        INC A
        LD (ZMEMT),A            ;PAGE NUMBER
        LD HL,(ZCODEP)          ;^ START OF ZCODE BUFFER
        LD BC,200H
        LD E,0
;
;LOAD PRELOAD
START2: LD A,D                  ;A <= PAGES REMAINING TO BE LOADED
        OR A                    ;DONE?
        JP Z,START3             ;YES
        DEC D
        ADD HL,BC
        INC E
        LD A,E
        PUSH BC
        PUSH DE
        PUSH HL
        CALL GETDSK
        POP HL
        POP DE
        POP BC
        JP START2
;
START3: LD HL,(ZCODEP)
        EX DE,HL
        LD HL,ZSWAP
        ADD HL,DE
        LD A,(HL)
        AND 1
        CALL NZ,ZER             ;SWAPPED
        LD HL,ZSTART+1
        ADD HL,DE
        LD A,(HL)
        LD (ZPCL),A
        DEC HL
        LD A,(HL)
        AND 1
        LD (ZPCL+1),A
        LD A,(HL)
        RRCA
        AND 7FH
        LD (ZPCH),A
        LD HL,ZGLOBA
        ADD HL,DE               ;GET RELATIVE ADDRESS OF GLOBAL TABLE
        PUSH DE
        LD D,(HL)
        INC HL
        LD E,(HL)
        EX DE,HL
        POP DE
        ADD HL,DE               ;REAL ADDRESS OF GLOBAL TABLE
        LD (GLOBAL),HL          ;STORE IT
        LD HL,ZFWORD
        ADD HL,DE               ;GET RELATIVE ADDRESS OF FWORDS TABLE
        PUSH DE
        LD D,(HL)
        INC HL
        LD E,(HL)
        EX DE,HL
        POP DE
        ADD HL,DE               ;REAL ADDRESS OF FWORDS TABLE
        LD (FWORDS),HL          ;STORE IT
        LD HL,ZENDLD            ;CALCULATE ^ TO BEGINNING OF PAGE BUFFERS
        ADD HL,DE
        PUSH DE
        LD D,(HL)
        INC HL
        LD E,(HL)
        POP HL
        ADD HL,DE
        INC HL
        LD (PGBUFP),HL          ;STORE IT
        DEC HL                  ;CALCULATE NO. OF AVAILABLE PAGES
        EX DE,HL                ;TOP LOCATION
        CALL MEMTOP
        LD A,H
        SUB D
        RRCA
        AND 7FH                 ;SWAPPING SPACE
        CP MAXPGS
        JP C,STAR3A
        LD A,MAXPGS
STAR3A: LD (NPGS),A             ;SAVE NUMBER OF PAGES
        DEC A
        LD (PGBOT),A
        LD HL,PGTBLF
        CALL HLOFF
        LD (HL),0FFH            ;SET LAST PAGE
;
;INITIALIZE RANDOM NUMBER
        LD B,5
        LD HL,0FFFFH
        LD (SHIFT),HL
        LD (SHIFT+2),HL
        LD HL,RDFLG             ;SET FLAG TO 1ST READ
        LD (HL),0
START4: CALL RND
        DEC B
        JP NZ,START4
        XOR A
        LD (NOLPT),A            ;USE LPT
        LD HL,(ZCODEP)
        LD DE,ZSWAP
        ADD HL,DE
        LD A,(HL)
        LD B,A
        LD A,(BSTLIN)           ;IS THERE A STATUS LINE?
        OR A
        LD A,B
        JP NZ,START5
        OR ZSTATB               ;INDICATE NO STATUS LINE
START5: LD (HL),A
        ;JP MLOOP               ;COMMENTED OUT FOR FALL THROUGH
;
;**********************************************************************
;*            MAINLOOP                                                *
;**********************************************************************
;
;MAIN LOOP, READ AN INSTRUCTION AND ITS ARGS, THEN DISPATCH
;
MLOOP:  XOR A
        LD (ARGCNT),A           ;ZERO ARG COUNT
        CALL NEXTPC             ;GET NEXT OPCODE IN A
        LD (OPCODE),A           ;SAVE IT
        CP 128
        JP C,OP2                ;2-OP
        CP 176
        JP C,OP1                ;1-OP
        CP 192
        JP C,OP0                ;0-OP
;
;HANDLE AN X-OP
OPEXT:  CALL NEXTPC             ;GET VAR TYPES, THIS IS AN EXT OP
        LD DE,ARG1
        LD B,4                  ;MAX NUMBER OF ARGS
        LD C,A
OPEXTL: PUSH BC
        PUSH DE
        LD A,C
        AND 0C0H                ;ISOLATE BIT7, BIT6 TO DETERMINE ARG TYPE
        CALL Z,GETLNG           ;00=LONG IMMEDIATE
        CP 80H
        CALL Z,GETVAR           ;10=VARIABLE
        CP 40H
        CALL Z,GETSHT           ;01=SHORT IMMEDIATE
        POP DE
        POP BC
        CP 0C0H                 ;11=NO MORE VARIABLES
        JP Z,OPEXTF             ;ALL DONE?
        EX DE,HL                ;NO - STORE VALUE
        LD (HL),E
        INC HL
        LD (HL),D
        INC HL
        EX DE,HL                ;POINTER BACK IN DE
        LD HL,ARGCNT
        INC (HL)                ;ONE MORE ARG
        LD A,C
        RLCA
        RLCA                    ;GET TO NEXT ARG TYPE
        LD C,A
        DEC B                   ;DECREMENT ARG COUNT
        JP NZ,OPEXTL            ;LOOP FOR MORE
;
;DISPATCH THE X-OP
OPEXTF: LD HL,OPEXTT            ;COMPUTE DISPATCH POINTER
        LD A,(OPCODE)           ;RETRIEVE THE OPCODE
        CP 224                  ;IS IT AN EXTENDED 2-OP?
        JP C,OP2EX              ;YES
        SUB 224                 ;NO
        CP OPEXTM               ;IS IT A LEGAL X-OP?
        JP NC,BADOP             ;NO
;
;GENERALIZED DISPATCH
OPDSPH: ADD A,A                 ;FORM A WORD OFFSET (*2)
        LD C,A                  ;PUT OFFSET INTO BC
        LD B,0
        ADD HL,BC               ;ADD OFFSET TO DISPATCH POINTER
        LD E,(HL)               ;ADDRESS LSB
        INC HL
        LD D,(HL)               ;ADDRESS MSB
        LD HL,(ARG1)            ;FIRST ARG
        EX DE,HL                ;HL ^ TABLE ADDRESS OF ROUTINE
                                ;DE <= FIRST ARG
        LD A,(ARGCNT)           ;B <= ARG COUNT
        LD B,A
        JP (HL)                 ;GO TO IT
;
;HANDLE A 0-OP
OP0:    SUB 176                 ;ADJUST VALUE
        CP OP0M                 ;IS IT A LEGAL 0-OP?
        JP NC,BADOP             ;NO
        LD HL,OP0T              ;YES - HL ^ 0-OP TABLE
        JP OPDSPH ;DISPATCH IT
;
;HANDLE A 1-OP
OP1:    AND 30H                 ;1 OP, ISOLATE BITS 5,4
        CALL Z,GETLNG           ;00=LONG IMMEDIATE
        CP 10H
        CALL Z,GETSHT           ;01=SHORT IMMEDIATE
        CP 20H
        CALL Z,GETVAR           ;10=VARIABLE
        LD A,1
        LD (ARGCNT),A           ;1 ARG
        LD (ARG1),HL            ;STORE IT
        LD A,(OPCODE)           ;RESTORE OPCODE
        AND 0CFH                ;(NOT 30H) TURN OFF MODE BITS
        SUB 128                 ;ADJUST VALUE
        CP OP1M                 ;LEGAL 1-OP?
        JP NC,BADOP             ;NO
        LD HL,OP1T              ;YES - HL ^ 1-OP TABLE
        JP OPDSPH               ;DISPATCH IT
;
;HANDLE A 2-OP
OP2:    AND 40H                 ;ISOLATE 1ST ARG BIT
        CALL NZ,GETVAR          ;1=VARIABLE
        CALL Z,GETSHT           ;0=SHORT IMMEDIATE
        LD (ARG1),HL            ;STORE ARG1
        LD A,(OPCODE)           ;RESTORE OPCODE
        AND 20H                 ;ISOLATE 2ND ARG BIT
        CALL NZ,GETVAR          ;1=VARIABLE
        CALL Z,GETSHT           ;2=SHORT IMMEDIATE
        LD (ARG2),HL            ;STORE ARG 2
        LD A,2
        LD (ARGCNT),A           ;TWO ARGS
        LD A,(OPCODE)           ;RESTORE OPCODE
OP2EX:  AND 1FH                 ;(NOT 0E0H) TURN OFF MODE BITS
        CP OP2M                 ;LEGAL 2-OP?
        JP NC,BADOP             ;NO
        LD HL,OP2T              ;YES - HL ^ 2-OP TABLE
        JP OPDSPH ;DISPATCH IT
;
;**********************************************************************
;*            OPCODE ARGUMENT FETCH SUBROUTINES                       *
;**********************************************************************
;
;----------------------------------------------------------------------
;FETCH A SHORT IMMEDIATE
;----------------------------------------------------------------------
GETSHT: PUSH AF                 ;SAVE OPCODE
        CALL NEXTPC             ;GET NEXT ZBYTE
        LD L,A                  ;MAKING IT THE LSB OF ARGUMENT
        LD H,0                  ;MSB IS 0
        POP AF                  ;RESTORE OPCODE
        RET
;----------------------------------------------------------------------
;FETCH A LONG IMMEDIATE
;----------------------------------------------------------------------
GETLNG: PUSH AF                 ;SAVE OPCODE
        CALL NEXTPC             ;GET NEXT ZBYTE
        LD H,A                  ;MAKING IT THE MSB OF ARGUMENT
        PUSH HL                 ;SAVE IT ON THE STACK
        CALL NEXTPC             ;GET NEXT ZBYTE
        POP HL                  ;RESTORE MSB OF ARGUMENT
        LD L,A                  ;AND FILL IN LSB OF ARGUMENT
        POP AF                  ;RESTORE OPCODE
        RET
;----------------------------------------------------------------------
;FETCH A VARIABLE
;----------------------------------------------------------------------
GETVAR: PUSH AF                 ;GET VAR, FIRST FIND TYPE
        CALL NEXTPC
        OR A
        JP Z,GETVRS             ;FROM STACK
GETVR1: CP 16
        JP NC,GETVRG            ;GLOBAL
GETVRL: DEC A                   ;LOCAL
        ADD A,A
        LD E,A
        LD D,0
        LD HL,LOCALS
GETVL1: ADD HL,DE               ;POINTER TO VARIABLE
        LD D,(HL)
        INC HL
        LD E,(HL)
        EX DE,HL                ;RETURN VALUE IN HL
        POP AF
        RET
;
GETVRG: SUB 16
        LD E,A                  ;GET GLOBAL
        LD D,0
        LD HL,(GLOBAL)
        ADD HL,DE               ;PRE ADD SO IT GETS DONE TWICE
        JP GETVL1
;
GETVRS: CALL POPSTK             ;VAR FROM STACK
        POP AF
        RET
;
;**********************************************************************
;*            MISC. SUBROUTINES                                       *
;**********************************************************************
;
RET0:   XOR A                   ;RETURN 0
PUTBYT: LD L,A
        LD H,0
PUTVAL: CALL PUTVLC             ;STORE VALUE
        JP MLOOP
;
PUTVLC: PUSH HL                 ;SAVE VALUE
        CALL NEXTPC             ;GET TYPE
        POP HL
PUTVR1: OR A
        JP Z,PSHSTK             ;SAVE ON STACK AND RETURN
        EX DE,HL                ;VALUE IN DE
        CP 16
        JP NC,PUTVLG            ;GLOBAL
PUTVLL: DEC A                   ;LOCAL
        ADD A,A
        LD C,A
        LD B,0
        LD HL,LOCALS
PUTVL1: ADD HL,BC               ;COMPUTE ADDRESS
        LD (HL),D
        INC HL
        LD (HL),E
        RET
;
PUTVLG: SUB 16
        LD C,A                  ;STORE GLOBAL
        LD B,0
        LD HL,(GLOBAL)          ;GLOBAL POINTER
        ADD HL,BC               ;PRE ADD
        JP PUTVL1
;
;**********************************************************************
;*            DATA MANIPULATION                                       *
;**********************************************************************
;
;----------------------------------------------------------------------
;RECALL A VARIABLE
;----------------------------------------------------------------------
VARGET: PUSH AF                 ;SAVE OPCODE
        OR A                    ;IF NON-ZERO
        JP NZ,GETVR1            ;THEN GET A VARIABLE FROM LOCAL OR GLOBAL TABLE
                                ;ELSE TAKE VAR OFF STACK
VARGTS: POP AF                  ;RESTORE OPCODE
        CALL POPSTK             ;POP A WORD FROM ZSTACK
        JP PSHSTK               ;PUT IT BACK AND RETURN THE VALUE IN HL
;----------------------------------------------------------------------
;STORE A VARIABLE
;----------------------------------------------------------------------
VARPUT: OR A                    ;IF NON-ZERO
        JP NZ,PUTVR1            ;THEN PUT A VARIABLE IN LOCAL OR GLOBAL TABLE
                                ;ELSE REPLACE A WORD ON Z-STACK
VARPTS: PUSH HL                 ;SAVE NEW VALUE
        CALL POPSTK             ;POP OLD WORD OFF Z-STACK
        POP HL                  ;RESTORE NEW VALUE
        JP PSHSTK               ;AND PUSH IT ON TOP OF ZSTACK
;
;**********************************************************************
;*            PREDICATE PROCESSING                                    *
;**********************************************************************
;
;----------------------------------------------------------------------
;PREDICATE FAILS
;----------------------------------------------------------------------
PREDF:  CALL NEXTPC             ;FETCH NEXT BYTE OF ZCODE
        OR A
        JP P,PREDB              ;BRANCH IF < 128
PREDNB: AND 40H                 ;CHECK FOR MULTI BYTE HACK
        CALL Z,NEXTPC           ;GET NEXT BYTE IF SO
        JP MLOOP                ;CONTINUE IN SEQUENCE
;----------------------------------------------------------------------
;PREDICATE SUCCEEDS
;----------------------------------------------------------------------
PREDS:  CALL NEXTPC             ;FETCH NEXT BYTE OF ZCODE
        OR A                    ;IF BIT 7 IS NOT SET
        JP P,PREDNB             ;BRANCH ON PREDICATE FAILURE
                                ;ELSE FALL THROUGH TO PREDB
;----------------------------------------------------------------------
;PERFORM A BRANCH
;----------------------------------------------------------------------
PREDB:  LD B,A                  ;SAVE OPCODE
        AND 40H                 ;LONG BRANCH?
        JP Z,PREDLB             ;YES - (BIT 6 WAS OFF)
                                ;NO - SHORT BRANCH
        LD A,B                  ;RESTORE OPCODE
        AND 3FH                 ;FORM SHORT OFFSET
        LD C,A                  ;USE AS LSB OF BRANCH OFFSET
        LD B,0                  ;ZERO MSB OF OFFSET
        JP PREDB1               ;SIMULATE LONG BRANCH TO A CLOSE PLACE
;
;HANDLE A LONG BRANCH
PREDLB: LD A,B                  ;RESTORE OPCODE
        AND 3FH                 ;FORM MSB OF OFFSET
        LD B,A                  ;B <= MSB OF OFFSET
        PUSH BC
        CALL NEXTPC             ;GET SECOND BYTE
        POP BC
        LD C,A                  ;C <= LSB OF OFFSET
        LD A,B                  ;A <= MSB OF OFFSET
        AND 20H                 ;CHECK SIGN OF 14 BIT VALUE
        JP Z,PREDB1             ;POSITIVE
        LD A,B                  ;ELSE EXTEND THE SIGN (A <= MSB)
        OR 0C0H                 ;AND MAKE THE FULL WORD NEG
        LD B,A                  ;SAVE THE RESULT IN B
;
;BRANCH TO THE Z-ADDRESS AT $(ZPC) + OFFSET (IN BC)
;(ZPC RELATIVE ADDRESSING)
PREDB1: LD A,B
        OR C                    ;IS OFFSET=0?
        JP Z,RFALSE             ;YES - DO AN RFALSE
        DEC  BC
        LD A,B
        OR C                    ;WAS OFFSET=1
        JP Z,RTRUE              ;YES - DO AN RTRUE
PREDB3: DEC BC                  ;2 NOW SUBTRACTED FROM JUMP ADDRESS
        LD H,B                  ;HL <= JUMP ADDRESS
        LD L,C
        LD (ZPCOFF),HL          ;ZPCOFF <= JUMP ADDRESS
        LD HL,(ZPCL)            ;HL <= LOW ORDER 9 BITS OF ZIP PROGRAM COUNTER
        LD E,C                  ;E <= LSB OF JUMP ADDRESS
        LD A,B                  ;A <= MSB OF JUMP ADDRESS
        AND 1
        LD D,A                  ;ZPCL ADDER
        LD A,B                  ;ARITHMETICALLY SHIFT B RIGHT 1
        RLCA                    ;FIRST SET CARRY
        LD A,B
        RRA
        LD B,A                  ;CUTE
        ADD HL,DE
        LD A,H
        AND 2
        JP Z,PREDB2             ;NO OVERFLOW
        DEC H
        DEC H                   ;OVERFLOW
        INC B
PREDB2: LD (ZPCL),HL            ;STORE LOW BYTES
        LD HL,ZPCH              ;MODIFY UPPER
        LD A,B
        OR A
        JP Z,PREDB4             ;NO CHANGE IN PACE, DO FASTER JUMP
        ADD A,(HL)
        LD (HL),A
        XOR A
        LD (ZPCFLG),A           ;CHANGED PAGES
        JP MLOOP                ;FINISHED
;
PREDB4: LD HL,(ZPCPNT)
        EX DE,HL
        LD HL,(ZPCOFF)
        ADD HL,DE               ;CALCULATE NEW PC POINTER
        LD (ZPCPNT),HL
        JP MLOOP
;
;**********************************************************************
;*            OPCODE PROCESSING SECTION                               *
;**********************************************************************
;
;**********************************************************************
;*            DISPATCH TABLES                                         *
;**********************************************************************
;
;----------------------------------------------------------------------
;0-OPS
;----------------------------------------------------------------------
OP0T:   DW RTRUE                ;0
        DW RFALSE               ;1
        DW PRINTI               ;2
        DW PRINTR               ;3
        DW ZNOP                 ;4
        DW ZSAVE                ;5
        DW ZRSTOR               ;6
        DW ZRSTAR               ;7
        DW RSTACK               ;8
        DW FSTACK               ;9
        DW ZQUIT                ;10
        DW CRLF                 ;11
        DW USL                  ;12
        DW VERIFY               ;13
OP0M    EQU ($-OP0T)/2          ;NUMBER OF 0-OPS
;
;----------------------------------------------------------------------
;1-OPS
;----------------------------------------------------------------------
OP1T:   DW ZEROQ                ;0
        DW NEXTQ                ;1
        DW FIRSTQ               ;2
        DW LOC                  ;3
        DW PTSIZE               ;4
        DW INC                  ;5
        DW DEC                  ;6
        DW PRINTB               ;7
        DW BADOP                ;8 (UNDEFINED)
        DW REMOVE               ;9
        DW PRINTD               ;10
        DW RETURN               ;11
        DW JUMP                 ;12
        DW PRINT                ;13
        DW VALUE                ;14
        DW BCOM                 ;15
OP1M    EQU ($-OP1T)/2          ;NUMBER OF 1-OPS
;
;----------------------------------------------------------------------
;2-OPS
;----------------------------------------------------------------------
OP2T:   DW BADOP
        DW EQUALQ
        DW LESSQ
        DW GRTRQ
        DW DLESSQ
        DW IGRTRQ
        DW INQ
        DW BTST
        DW BOR
        DW BAND
        DW FSETQ
        DW FSET
        DW FCLEAR
        DW ZSET
        DW MOVE
        DW GET
        DW GETB
        DW GETP
        DW GETPT
        DW NEXTP
        DW ZADD
        DW ZSUB
        DW MUL
        DW DIV
        DW ZMOD
OP2M    EQU ($-OP2T)/2
;
;----------------------------------------------------------------------
;X-OPS
;----------------------------------------------------------------------
OPEXTT: DW ZCALL
        DW PUT
        DW PUTB
        DW PUTP
        DW ZREAD
        DW PRINTC
        DW PRINTN
        DW RANDOM
        DW ZPUSH
        DW ZPOP
OPEXTM  EQU ($-OPEXTT)/2
;
;**********************************************************************
;*            ZCODE EXECUTION ROUTINES                                *
;**********************************************************************
;
;**********************************************************************
;*            0-OPS                                                   *
;**********************************************************************
;
;----------------------------------------------------------------------
;RTRUE [0] 
;----------------------------------------------------------------------
;SIMULATE A RETURN 1
RTRUE:  LD HL,1
RTRUE1: LD (ARG1),HL
        JP RETURN
;
;----------------------------------------------------------------------
;RFALSE [1] 
;----------------------------------------------------------------------
;SIMULATE A RETURN 0
RFALSE: LD HL,0
        JP RTRUE1
;
;----------------------------------------------------------------------
;PRINTI [2] 
;----------------------------------------------------------------------
;PRINT THE Z-STRING IMMEDIATELY FOLLOWING THE OPCODE
PRINTI: CALL PRNTI1
        JP MLOOP
;
PRNTI1: LD HL,(ZPCL)
        LD (MPCL),HL            ;SET UP MPC TO EQUAL ZPC
        LD A,(ZPCH)
        LD (MPCH),A
        XOR A
        LD (MPCFLG),A           ;ZERO MPC FLAG
        CALL PZSTR              ;PRINT THE STRING
        LD HL,(MPCL)            ;NOW CHANGE BACK ZPC TO END OF STRING
        LD (ZPCL),HL
        LD A,(MPCH)
        LD (ZPCH),A
        LD A,(MPCFLG)
        LD (ZPCFLG),A           ;UPDATE FLAG
        LD HL,(MPCPNT)
        LD (ZPCPNT),HL          ;AND PAGE POINTER
        RET
;
;----------------------------------------------------------------------
;PRINTR [3] 
;----------------------------------------------------------------------
;EXECUTE A PRINTI, FOLLOWED BY A CRLF, AND A RTRUE
PRINTR: CALL PRNTI1
        CALL PCRLF
        JP RTRUE
;
;----------------------------------------------------------------------
;ZNOP [4] 
;----------------------------------------------------------------------
;EXECUTE A NOP
ZNOP:   JP MLOOP
;
;----------------------------------------------------------------------
;ZSAVE [5] 
;----------------------------------------------------------------------
;SAVE GAME
ZSAVE:  JP SAVE                 ;MACHINE DEPENDENT
;
;----------------------------------------------------------------------
;ZRSTOR [6] 
;----------------------------------------------------------------------
;RESTORE SAVED GAME
ZRSTOR: JP RESTOR               ;MACHINE DEPENDENT
;
;----------------------------------------------------------------------
;ZRSTAR [7] 
;----------------------------------------------------------------------
;RESTART GAME
ZRSTAR: JP RESTAR               ;MACHINE DEPENDENT
;
;----------------------------------------------------------------------
;RSTACK [8] 
;----------------------------------------------------------------------
;EXECUTE A RETURN WITH CALL VALUE ON TOP OF THE STACK
RSTACK: CALL POPSTK
        LD (ARG1),HL
        JP RETURN
;
;----------------------------------------------------------------------
;FSTACK [9] 
;----------------------------------------------------------------------
FSTACK: CALL POPSTK
        JP MLOOP
;
;----------------------------------------------------------------------
;ZQUIT [10] 
;----------------------------------------------------------------------
ZQUIT:  JP QUIT                 ;MACHINE DEPENDENT
;
;----------------------------------------------------------------------
;CRLF [11] 
;----------------------------------------------------------------------
;PRINT CARRIAGE RETURN/LINE FEED
CRLF:   CALL PCRLF
        JP MLOOP
;
;----------------------------------------------------------------------
;USL [12] 
;----------------------------------------------------------------------
;UPDATE STATUS LINE
USL:    CALL WHOLIN
        JP MLOOP
;
;----------------------------------------------------------------------
;VERIFY [13] 
;----------------------------------------------------------------------
;VERIFY THE GAME CODE
VERIFY: LD A,1                  ;SELF CHECK
        LD (VERF),A             ;IN VERIFY MODE, ALWAYS GET NEW PAGE
        LD HL,VRS
        CALL MSGOUT             ;OUTPUT LAST UPDATE
        LD HL,VRLINE
        CALL MSGOUT             ;OUTPUT VERSION
        LD HL,(ZCODEP)          ;^ TOP OF ZCODE
        LD DE,ZCKLEN
        ADD HL,DE
        LD D,(HL)
        INC HL
        LD E,(HL)
        LD HL,-32
        ADD HL,DE
        EX DE,HL                ;DE HAVE COUNT
        LD BC,0                 ;SUM IN BC
        LD HL,32*2
        CALL SETWRD
VERIFL: PUSH BC
        PUSH DE
        CALL GETWRD             ;GUARENTEED TO GET FRESH WORD
        POP DE
        POP BC
        LD A,H
        LD H,0
        ADD HL,BC
        CALL HLOFF
        LD B,H
        LD C,L                  ;TOTAL IN BC
        DEC DE
        LD A,D
        OR E
        JP NZ,VERIFL            ;SUM ALL BYTES
        LD DE,ZCKSUM
        LD HL,(ZCODEP)
        ADD HL,DE
        LD D,(HL)
        INC HL
        LD E,(HL)               ;GET CHECKSUM
        LD H,B
        LD L,C
        XOR A
        LD (VERF),A
        CALL HLGEDE             ;COMPARE CALCULATED WITH ACTUAL
        JP Z,PREDS
        JP PREDF                ;FAIL IF DIFFERENT
;
;**********************************************************************
;*            1-OPS                                                   *
;**********************************************************************
;
;----------------------------------------------------------------------
;ZERO? [0] 
;----------------------------------------------------------------------
;IS ARG1 EQUAL TO ZERO? [PRED]
ZEROQ:  LD HL,(ARG1)
        LD A,H
        OR L
        JP Z,PREDS
        JP PREDF
;
;----------------------------------------------------------------------
;NEXT? [1] 
;----------------------------------------------------------------------
;RETURN THE NEXT POINTER IN OBJRCT "ARG1"; FAIL IF NONE LEFT, AND RETURN ZERO [VALUE][PRED]
NEXTQ:  LD A,(ARG1)
        CALL OBJLOC
        LD DE,5
        JP FRSTQ1               ;SAME AS FIRST?
;
;----------------------------------------------------------------------
;FIRST? [2] 
;----------------------------------------------------------------------
;RETURN THE FIRST POINTER IN OBJECT "ARG1" - FAIL IF NONE, AND RETURN ZERO [VALUE][PRED]
FIRSTQ: LD A,(ARG1)
        CALL OBJLOC
        LD DE,6
FRSTQ1: ADD HL,DE
        LD A,(HL)
        PUSH AF                 ;SAVE VALUE
        LD L,A
        LD H,0
        CALL PUTVLC             ;STORE VALUE
        POP AF
        OR A
        JP NZ,PREDS             ;FOUND FIRST
        JP PREDF                ;FIRST NOT FOUND
;
;----------------------------------------------------------------------
;LOC [3] 
;----------------------------------------------------------------------
;RETURN THE OBJECT CONTAINING OBJECT "ARG1" - ZERO IF NONE [VALUE]
LOC:    LD A,(ARG1)
        CALL OBJLOC
        LD DE,4
        ADD HL,DE
        LD L,(HL)
        LD H,0
        JP PUTVAL
;
;----------------------------------------------------------------------
;PTSIZE [4] 
;----------------------------------------------------------------------
;RETURN LENGTH OF PROP TABLE "ARG1" IN BYTES [VALUE]
PTSIZE: LD HL,(ARG1)
        EX DE,HL
        LD HL,(ZCODEP)
        ADD HL,DE               ;POINTER TO PROP ENTRY
        DEC HL
        CALL PROPL
        INC A
        JP PUTBYT
;
;----------------------------------------------------------------------
;INC [5] 
;----------------------------------------------------------------------
;INCREMENT ARG1 [VALUE]
INC:    CALL INC1
        JP MLOOP
;
;----------------------------------------------------------------------
;DEC [6] 
;----------------------------------------------------------------------
;DECREMENT ARG1 [VALUE]
DEC:    CALL DEC1
        JP MLOOP
;
INC1:   LD A,(ARG1)
        CALL VARGET
        INC HL
INC2:   PUSH HL
        CALL VARPUT
        POP HL
        RET
;
DEC1:   LD A,(ARG1)
        CALL VARGET
        DEC HL
        JP INC2
;
;----------------------------------------------------------------------
;PRINTB [7] 
;----------------------------------------------------------------------
;PRINT THE STRING POINTED TO BY BYTE POINTER ARG1
PRINTB: LD HL,(ARG1)
PRINT2: CALL SETWRD
        JP PRINT1
;
;----------------------------------------------------------------------
;BADOP [8] 
;----------------------------------------------------------------------
BADOP:  JP MLOOP
;
;----------------------------------------------------------------------
;REMOVE [9] 
;----------------------------------------------------------------------
;MOVE OBJECT [ARG1] TO PSEUDO-OBJECT #0
REMOVE: CALL REMOVC
        JP MLOOP
;
REMOVC: LD A,(ARG1)
        LD B,A                  ;SAVE IT
        CALL OBJLOC
        EX DE,HL                ;SAVE IN DE
        LD HL,4
        ADD HL,DE
        LD A,(HL)
        OR A
        RET Z                   ;NO OBJECT
        PUSH DE                 ;SAVE VALUE
        CALL OBJLOC             ;PARENT OBJECT
        LD DE,6
        EX DE,HL                ;LP IN D
        ADD HL,DE
        LD C,(HL)               ;SIBL
        LD A,B
        CP C
        JP NZ,REMVC1            ;NOT SAME
        POP HL
        PUSH HL                 ;L1
        LD BC,5
        ADD HL,BC
        LD A,(HL)
        LD HL,6                 ;PARENT'S FIRST SLOT GETS LOC SLOT
        ADD HL,DE
        LD (HL),A
        JP REMVC2
;
REMVC1: LD A,C                  ;GET SIBL
        CALL OBJLOC
        LD DE,5
        ADD HL,DE
        LD D,H
        LD E,L                  ;SAVE LS+5
        LD C,(HL)               ;NEW SIBL
        LD A,B
        CP C
        JP NZ,REMVC1            ;NOT END OF CHAIN
        LD BC,5
        POP HL
        PUSH HL
        ADD HL,BC               ;OLD NEXT
        LD A,(HL)
        LD (DE),A
REMVC2: POP HL
        LD DE,4
        ADD HL,DE
        LD (HL),0
        INC HL
        LD (HL),0
        RET
;
;----------------------------------------------------------------------
;PRINTD [10] 
;----------------------------------------------------------------------
;PRINT SHORT DESCRIPTION OF OBJECT [ARG1]
PRINTD: LD A,(ARG1)
        CALL PRNTDC
        JP MLOOP
;
PRNTDC: CALL OBJLOC
        LD DE,7
        ADD HL,DE
        LD D,(HL)
        INC HL
        LD E,(HL)
        EX DE,HL
        INC HL
        CALL SETWRD
        JP PZSTR
;
;----------------------------------------------------------------------
;RETURN [11] 
;----------------------------------------------------------------------
;RETURN FROM A CALL WITH VALUE ARG1
RETURN: LD HL,(OZSTKP)          ;RESET STACK FROM CALL
        LD (ZSTAKP),HL
        LD A,(OZSTKC)
        LD (ZSTAKC),A
        CALL POPSTK             ;RESET Z-STACK
        LD A,L
        LD (ZPCH),A             ;SAVE UPPER PC
        LD B,H                  ;H HAS NUMBER OF LOCALS
        LD A,H
        ADD A,A                 ;WORD
        JP Z,RET2               ;NO LOCALS
        LD HL,LOCALS-2
        CALL HLOFF              ;POSITION HL TO RESTORE LOCALS
RET1:   EX DE,HL
        CALL POPSTK             ;GET THE LOCAL, REVERSE ORDER FIRST
        EX DE,HL
        LD (HL),D
        INC HL
        LD (HL),E
        DEC HL                  ;NOW BACK UP ONE ELEMENT
        DEC HL
        DEC HL
        DEC B
        JP NZ,RET1              ;LOOP
RET2:   CALL POPSTK
        LD (ZPCL),HL            ;REST OF PC
        CALL POPSTK
        LD (OZSTKP),HL
        CALL POPSTK
        LD A,L
        LD (OZSTKC),A           ;RESTORE OLD VALUES
        XOR A
        LD (ZPCFLG),A           ;PC CHANGED
        LD HL,(ARG1)            ;ARGUMENT TO BE RETURNED
        JP PUTVAL               ;STORE AND RETURN
;
;----------------------------------------------------------------------
;JUMP [12] 
;----------------------------------------------------------------------
;BRANCH TO Z-LOCATION POINTED TO BY 16-BIT 2'S COMPLIMENT ARG1
JUMP:   LD HL,(ARG1)            ;RELATIVE JUMP
        LD B,H
        LD C,L
        DEC BC
        JP PREDB3               ;TREAT AS A SUCCESSFUL JUMP
;
;----------------------------------------------------------------------
;PRINT [13] 
;----------------------------------------------------------------------
;PRINT THE Z-STRING POINTED TO BY THE WORD-POINTER ARG1
PRINT:  LD HL,(ARG1)            ;TELL SETSTR WHERE THE STRING
        CALL SETSTR             ;RESIDES AND
PRINT1: CALL PZSTR              ;PRINT THE STRING
        JP MLOOP
;
;----------------------------------------------------------------------
;VALUE [14] 
;----------------------------------------------------------------------
;RETURN VALUE OF ARG1 [VALUE]
VALUE:  LD A,(ARG1)
        CALL VARGET
        JP PUTVAL
;
;----------------------------------------------------------------------
;BCOM [15] 
;----------------------------------------------------------------------
;COMPLIMENT ARG1 [VALUE]
BCOM:   LD HL,(ARG1)
        LD A,H
        CPL
        LD H,A
        LD A,L
        CPL
        LD L,A
        JP PUTVAL
;
;**********************************************************************
;*            2-OPS                                                   *
;**********************************************************************
;
;----------------------------------------------------------------------
;LESS? [0] 
;----------------------------------------------------------------------
;IS ARG1 LESS THAN ARG2? [PRED]
LESSQ:  CALL GETARG
        EX DE,HL
        CALL SHLGED
        JP NC,PREDS
        JP PREDF
;
;----------------------------------------------------------------------
;GRTR? [1] 
;----------------------------------------------------------------------
;IS ARG1 GREATER THAN ARG2? [PRED]
GRTRQ:  CALL GETARG
        CALL SHLGED
        JP NC,PREDS
        JP PREDF
;
;----------------------------------------------------------------------
;DLESS? [2] 
;----------------------------------------------------------------------
;DECREMENT ARG1 - SUCCEED IF ARG1 (-1) IS LESS THAN ARG2 [PRED]
DLESSQ: CALL DEC1
        EX DE,HL
        LD HL,(ARG2)
        EX DE,HL
        JP IGRTQ1
;
;----------------------------------------------------------------------
;IGRTR? [3] 
;----------------------------------------------------------------------
;INCREMENT ARG1 - SUCCEED IF ARG1 (+1) IS GREATER THAN ARG2 [PRED]
IGRTRQ: CALL INC1
        EX DE,HL
        LD HL,(ARG2)
IGRTQ1: CALL SHLGED
        JP NC,PREDS
        JP PREDF
;
;----------------------------------------------------------------------
;IN? [4] 
;----------------------------------------------------------------------
;IS OBJECT [ARG1] CONTAINED IN OBJECT [ARG2] [PRED]
INQ:    LD A,(ARG1)
        CALL OBJLOC
        LD DE,4
        ADD HL,DE
        LD A,(ARG2)
        CP (HL)
        JP Z,PREDS              ;SUCCESS IF OBJ 2 IN 1
        JP PREDF
;
;----------------------------------------------------------------------
;BTST [5] 
;----------------------------------------------------------------------
;IS EVERY "ON" BIT IN ARG1 ALSO "ON" IN ARG2 [PRED]
BTST:   CALL GETARG
        LD A,H
        AND D
        LD D,A
        LD A,L
        AND E
        LD E,A
        CALL HLGEDE
        JP Z,PREDS
        JP PREDF
;
;----------------------------------------------------------------------
;BOR [6] 
;----------------------------------------------------------------------
;RETURN BITWISE OR OF ARG1 AND ARG2 [VALUE]
BOR:    CALL GETARG
        LD A,D
        OR H
        LD H,A
        LD A,E
        OR L
        LD L,A
        JP PUTVAL
;
;----------------------------------------------------------------------
;BAND [7] 
;----------------------------------------------------------------------
;RETURN BITWISE AND OF ARG1 AND ARG2 [VALUE]
BAND:   CALL GETARG
        LD A,H
        AND D
        LD H,A
        LD A,L
        AND E
        LD L,A
        JP PUTVAL
;
;----------------------------------------------------------------------
;FSET? [8] 
;----------------------------------------------------------------------
;IS FLAG "ARG2" SET IN OBJECT "ARG1"? [PRED]
FSETQ:  CALL FLAGSU             ;GET BIT
        LD A,D
        AND B
        LD D,A
        LD A,E
        AND C
        OR D                    ;CHECK FOR ON
        JP NZ,PREDS             ;BIT ON
        JP PREDF                ;BIT OFF
;
;----------------------------------------------------------------------
;FSET [9] 
;----------------------------------------------------------------------
;SET FLAG "ARG2" IN OBJECT "ARG1"
FSET:   CALL FLAGSU
        LD A,D
        OR B
        LD (HL),A
        INC HL
        LD A,E
        OR C
        LD (HL),A
        JP MLOOP
;
;----------------------------------------------------------------------
;FCLEAR [10] 
;----------------------------------------------------------------------
;CLEAR FLAG "ARG2" IN OBJECT "ARG1"
FCLEAR: CALL FLAGSU
        LD A,B
        CPL
        AND D
        LD (HL),A
        INC HL
        LD A,C
        CPL
        AND E
        LD (HL),A
        JP MLOOP
;
;----------------------------------------------------------------------
;SET [11] 
;----------------------------------------------------------------------
;SET VARIABLE "ARG1" EQUAL TO VALUE "ARG2"
ZSET:   LD A,(ARG1)
        LD HL,(ARG2)
VARPTR: CALL VARPUT
        JP MLOOP
;
;----------------------------------------------------------------------
;MOVE [12] 
;----------------------------------------------------------------------
;PUT OBJECT "ARG1" INTO OBJECT "ARG2"
MOVE:   CALL REMOVC             ;REMOVE OBJECT FIRST
        LD A,(ARG1)
        CALL OBJLOC
        PUSH HL                 ;SAVE LOC OF FIRST ARG
        LD DE,4
        ADD HL,DE               ;LOC SLOT
        LD A,(ARG2)
        LD (HL),A
        CALL OBJLOC
        LD DE,6
        ADD HL,DE               ;FIRST SLOT
        LD B,(HL)
        LD A,(ARG1)
        LD (HL),A
        POP HL
        LD A,B
        OR A
        JP Z,MLOOP
        LD DE,5
        ADD HL,DE
        LD (HL),A               ;NEXT SLOT
        JP MLOOP
;
;----------------------------------------------------------------------
;GET [13] 
;----------------------------------------------------------------------
;RETURN VALUE OF ITEM "ARG2" IN WORD-TABLE AT "ARG1"
GET:    LD HL,(ARG2)
        ADD HL,HL               ;ITEM NUMBER*2
        EX DE,HL
        LD HL,(ARG1)
        ADD HL,DE               ;POINTER TO ITEM
        CALL SETWRD
        CALL GETWRD             ;GET VALUE
        JP PUTVAL
;
;----------------------------------------------------------------------
;GETB [14] 
;----------------------------------------------------------------------
;RETURN VALUE OF ITEM "ARG2" IN BYTE-TABLE AT "ARG1" [VALUE]
GETB:   LD HL,(ARG2)
        EX DE,HL
        LD HL,(ARG1)
        ADD HL,DE
        CALL SETWRD
        CALL GETBYT
        LD L,A
        LD H,0
        JP PUTVAL
;
;----------------------------------------------------------------------
;GETP [15] 
;----------------------------------------------------------------------
;RETURN PROP "ARG2" OF OBJECT "ARG1"; IF SPECIFIED PROP DOES NOT EXIST, RETURN  PROP'TH ELEMENT OF DEFAULT OBJECT [VALUE]
GETP:   CALL PROPB              ;GET POINTER TO PROPS IN PROP TABLE
GETP1:  CALL PROPN
        LD B,A
        LD A,(ARG2)
        CP B
        JP Z,GETP2              ;FOUND PROP
        JP NC,GETP3             ;GET PROP FROM DEFAULT TABLE
        CALL PROPNX             ;TRY AGAIN WITH NEXT PROP
        JP GETP1
;
GETP3:  LD HL,(ZCODEP)
        LD DE,ZOBJEC
        ADD HL,DE
        LD D,(HL)
        INC HL
        LD E,(HL)
        LD HL,(ZCODEP)
        ADD HL,DE               ;BEG OF OBJECT TABLE
        LD A,(ARG2)
        ADD A,A
        CALL HLOFF
        DEC HL
        LD E,(HL)
        DEC HL
        LD D,(HL)
        EX DE,HL
        JP PUTVAL               ;RETURN DEFAULT VALUE
;
GETP2:  CALL PROPL              ;GET LENGTH
        INC HL
        DEC A
        JP M,GETP2A             ;1 BYTE
        CALL NZ,ZER             ;BAD PROP LENGTH
        LD D,(HL)
        INC HL
        LD E,(HL)
        EX DE,HL
        JP PUTVAL               ;RETURN TWO BYTE PROP
;
GETP2A: LD L,(HL)
        LD H,0
        JP PUTVAL
;
GETPT:  CALL PROPB
GETPT1: CALL PROPN
        LD B,A
        LD A,(ARG2)
        CP B
        JP Z,GETPT2             ;FOUND PROP
        JP NC,RET0
        CALL PROPNX
        JP GETPT1
;
GETPT2: INC HL
        EX DE,HL
        LD HL,(ZCODEP)          ;SUBRACT OFF RELATIVE POINTER
        LD A,E
        SUB L
        LD L,A
        LD A,D
        SBC A,H
        LD H,A
        JP PUTVAL
;
NEXTP:  CALL PROPB              ;POINT TO PROP VALUE
        LD A,(ARG2)
        OR A
        JP Z,NEXTP2             ;PROP0
NEXTP1: CALL PROPN
        LD B,A
        LD A,(ARG2)
        CP B
        JP Z,NEXTP3             ;FOUND PROP
        JP NC,RET0              ;RETURN 0
        CALL PROPNX
        JP NEXTP1               ;LOOP
;
NEXTP2: CALL PROPN
        JP PUTBYT
;
NEXTP3: CALL PROPNX
        JP NEXTP2               ;PROPN OF NEXT
;
ZADD:   CALL GETARG
        ADD HL,DE
        JP PUTVAL
;
ZSUB:   CALL GETARG
        LD A,E
        SUB L
        LD L,A
        LD A,D
        SBC A,H
        LD H,A
        JP PUTVAL
;
MUL:    CALL GETARG
        EX DE,HL
        CALL SIGNC              ;CHECK SIGN
        PUSH HL
        LD HL,2
        CALL HLGEDE
        JP Z,MUL2
        LD HL,4
        CALL HLGEDE
        JP Z,MUL4
        POP HL
        CALL MULT               ;DO THE MULTIPLY
MUL1:   CALL SIGNS              ;SET THE SIGN
        JP PUTVAL               ;THEN STORE RESULT
;
MUL4:   POP HL
        ADD HL,HL
        PUSH HL
MUL2:   POP HL
        ADD HL,HL
        JP MUL1
;
DIV:    CALL GETARG
        EX DE,HL
        CALL SIGNC              ;CHECK SIGNS
        PUSH HL
        LD HL,2
        CALL HLGEDE
        JP Z,DIV2               ;DIVIDE BY 2
        LD HL,4
        CALL HLGEDE
        JP Z,DIV4               ;DIVIDE BY 4
        POP HL
        CALL DIVIDE             ;DO THE DIVIDE
        JP MUL1                 ;SET SIGN AND RETURN
;
DIV2:   POP HL
DIV2B:  CALL DIV2A
        JP MUL1
;
DIV4:   POP HL
        CALL DIV2A
        JP DIV2B
;
DIV2A:  OR A                    ;CLEAR CARRY
        LD A,H
        RRA
        LD H,A
        LD A,L
        RRA
        LD L,A
        RET
;
ZMOD:   CALL GETARG
        EX DE,HL
        CALL SIGNC              ;MAKE THEM POSITIVE
        CALL DIVIDE             ;DO THE DIVIDE
        EX DE,HL                ;GET THE REMAINDER
        JP PUTVAL
;
;**********************************************************************
;*            X-OPS                                                   *
;**********************************************************************
;
EQUALQ: LD HL,(ARG1)
        EX DE,HL
        LD A,(ARGCNT)
        LD B,A
        DEC B
        CALL Z,ZER
        LD HL,(ARG2)
        CALL EQUAQ1
        LD HL,(ARG3)
        CALL EQUAQ1
        LD HL,(ARG4)
        CALL EQUAQ1
        CALL ZER
;
EQUAQ1: CALL HLGEDE             ;DO COMPARISON
        POP HL                  ;RESTORE RETURN ADDRESS
        JP Z,PREDS              ;DON'T BOTHER RETURNING
        DEC B                   ;ARG COUNT
        JP Z,PREDF              ;OUT OF ARGS, FAIL
        JP (HL)                 ;ELSE RETURN
;
ZCALL:  LD HL,(ARG1)
        LD A,H
        OR L
        JP Z,PUTVAL
        LD HL,(OZSTKC)
        CALL PSHSTK
        LD HL,(OZSTKP)
        CALL PSHSTK
        LD HL,(ZPCL)
        CALL PSHSTK             ;SAVE OLD PC LOWER
        LD HL,(ZPCH)            ;SAVE HIGH IN L
        PUSH HL
        XOR A
        LD (ZPCFLG),A           ;PC HAS CHANGED
        LD H,A
        LD A,(ARG1)
        LD L,A
        ADD HL,HL               ;NEW ZPCL
        LD (ZPCL),HL
        LD A,(ARG1+1)
        LD (ZPCH),A             ;NEW ZPCH
        CALL NEXTPC             ;GET NUMBER OF LOCALS
        POP HL
        LD B,A                  ;B HAS NUMBER OF LOCALS
        LD H,A
        PUSH HL                 ;SAVE VALUE
        LD HL,LOCALS            ;STORE OLD LOCALS
        OR A
        JP Z,ZCALL2             ;NO LOCALS
ZCALL1: PUSH BC
        LD D,(HL)
        INC HL
        LD E,(HL)
        EX DE,HL
        CALL PSHSTK
        DEC DE
        PUSH DE
        CALL NEXTPC             ;GET NEW DEFAULT VALUE FOR LOCAL
        LD D,A
        PUSH DE
        CALL NEXTPC             ;WORD VALUE
        POP DE
        LD E,A
        POP HL                  ;POINTER TO STORE NEW LOCAL
        LD (HL),D
        INC HL
        LD (HL),E
        INC HL
        POP BC
        DEC B
        JP NZ,ZCALL1            ;LOOP THROUGH ALL LOCALS
ZCALL2: LD A,(ARGCNT)           ;PASS ARGS
        LD B,A
        DEC B
        JP Z,ZCALL4             ;NO ARGS TO PASS
        LD HL,ARG2              ;POINTER TO FIRST ARG
        LD DE,LOCALS
ZCALL3: LD A,(HL)
        INC HL
        INC DE
        LD (DE),A
        DEC DE
        LD A,(HL)
        INC HL
        LD (DE),A
        INC DE
        INC DE
        DEC B
        JP NZ,ZCALL3
ZCALL4: POP HL                  ;GET BACK ZPCH AND NUMBER OF LOCALS
        CALL PSHSTK
        LD A,(ZSTAKC)
        LD (OZSTKC),A
        LD HL,(ZSTAKP)
        LD (OZSTKP),HL          ;FOR KNOWING WHERE TO RETURN
        JP MLOOP
;
PUT:    LD HL,(ARG2)
        ADD HL,HL
        EX DE,HL
        LD HL,(ARG1)
        ADD HL,DE               ;Z ADDRESS
        EX DE,HL
        LD HL,(ZCODEP)
        ADD HL,DE               ;REAL POINTER
        EX DE,HL
        LD HL,(ARG3)            ;VALUE TO STORE
        EX DE,HL
        LD (HL),D
        INC HL
        LD (HL),E
        JP MLOOP
;
PUTB:   LD HL,(ARG2)
        EX DE,HL
        LD HL,(ARG1)
        ADD HL,DE
        EX DE,HL
        LD HL,(ZCODEP)
        ADD HL,DE
        LD A,(ARG3)
        LD (HL),A               ;STORE ONE BYTE IN RANDOM TABLE
        JP MLOOP
;
PUTP:   CALL PROPB              ;SET PROP
PUTP1:  CALL PROPN              ;GET PROP NUMBER
        LD B,A
        LD A,(ARG2)
        CP B
        JP Z,PUTP2              ;FOUND PROPERTY
        CALL NC,ZER             ;BAD PROP NUMBER
        CALL PROPNX             ;TRY NEXT
        JP PUTP1
;
PUTP2:  CALL PROPL              ;GET LENGTH
        INC HL
        EX DE,HL
        LD HL,(ARG3)
        DEC A
        JP M,PUTP2A             ;STORE 1 BYTE
        CALL NZ,ZER             ;TOO LONG
        EX DE,HL
        LD (HL),D
        INC HL
        LD (HL),E
        JP MLOOP                ;RETURN
;
PUTP2A: EX DE,HL
        LD (HL),E
        JP MLOOP                ;SET AND RETURN
;
ZREAD:  CALL WHOLIN
        CALL RND                ;RANDOMIZE
        LD HL,(ZCODEP)          ;MAIN READ CODE
        EX DE,HL                ;GET REAL POINTERS TO TABLES
        LD HL,(ARG1)
        ADD HL,DE               ;BUFFER TABLE
        LD (ARG1),HL
        LD HL,(ARG2)
        ADD HL,DE               ;RESULT TABLE
        LD (ARG2),HL
        CALL READBF             ;READ THE BUFFER
        LD B,A                  ;CHARACTER COUNT IN B
        LD C,0                  ;C HAS CHARACTERS IN WORD
        LD HL,(ARG2)
        INC HL
        LD (HL),0               ;SET WORDS READ TO 0
        INC HL
        LD (RTABP),HL           ;INITIALIZE RESULT TABLE POINTER
        LD HL,(ARG1)
        INC HL                  ;HL HAS POINTER TO INPUT CHARACTERS
READL:  PUSH HL
        LD HL,(ARG2)
        LD A,(HL)
        INC HL
        CP (HL)
        POP HL
        JP Z,MLOOP              ;TOO MANY WORDS
;ERROR HERE IF DESIRED INSTEAD OF JZ
        LD A,B
        OR C
        JP Z,MLOOP              ;OUT OF CHARACTERS AND WORDS
        LD A,C
        CP 6
        CALL Z,FLUSHW           ;FLUSH CHARS IN A WORD OVER 6 CHARACTERS
        LD A,C
        OR A
        JP NZ,READL2            ;NOT FIRST CHARACTER IN WORD
        PUSH HL
        LD D,6
        LD HL,ZSTBUI            ;INITIALIZE WORD BUFFER
RD0PL:  LD (HL),0
        INC HL
        DEC D
        JP NZ,RD0PL
        POP HL
        LD A,(ARG1)
        LD D,A
        LD A,L
        SUB D                   ;POSITION OF START OF WORD
        PUSH HL
        LD HL,(RTABP)
        INC HL
        INC HL
        INC HL
        LD (HL),A               ;STORE IN RESULT TABLE
        POP HL
        LD A,(HL)
        CALL SIBRKQ             ;SELF INSERTING BREAK?
        JP C,RSIBRK
        LD A,(HL)
        CALL RBRKQ              ;NORMAL BREAK?
        JP NC,READL2            ;NO
        INC HL                  ;YES, FLUSH STRANDED BREAKS
        DEC B
        JP READL                ;LOOP BACK
;
READL2: LD A,B
        OR A
        JP Z,READL3             ;OUT OF CHARACTERS, SIMULATE WORD ENDING
        LD A,(HL)
        CALL RBRKQ              ;WORD BREAK?
        JP C,READL3             ;FOUND A BREAK
        LD D,(HL)
        PUSH HL
        LD HL,ZSTBUI
        LD A,C
        CALL HLOFF
        LD (HL),D               ;STORE CHARACTER IN BUFFER
        POP HL
        DEC B                   ;ONE LESS CHARACTER
        INC C                   ;ONE MORE CHARACTER IN WORD
        INC HL                  ;POINT TO NEXT CHARACTER
        JP READL
;
RSIBRK: LD (ZSTBUI),A           ;STORE SELF INSERTING BREAK
        INC C                   ;1 CHAR
        DEC B                   ;1 LESS CHAR
        INC HL
READL3: LD A,C                  ;INSERT WORD IF ANY CHARACTERS IN WORD
        OR A
        JP Z,READL              ;NO CHARACTERS IN WORD
        PUSH HL
        PUSH BC
        LD HL,(RTABP)           ;STORE PARAMS IN TABLE
        INC HL
        INC HL
        LD (HL),C               ;REAL LENGTH OF WORD
        CALL CONZST             ;CONVERT TO ZSTRING
        CALL FINDW              ;LOOK UP WORD IN VOCAB TABLE
        LD HL,(RTABP)           ;STORE RESULT
        LD (HL),D
        INC HL
        LD (HL),E
        INC HL
        INC HL
        INC HL
        LD (RTABP),HL           ;POINTER TO NEXT WORD
        LD HL,(ARG2)
        INC HL
        INC (HL)                ;ONE MORE WORD
        POP BC
        POP HL
        LD C,0                  ;ZERO CHARACTERS IN NEXT WORD
        JP READL
;
FLUSHW: LD A,B
        OR A                    ;FLUSH CHARACTERS TILL BREAD OR END OF BUFFER
        RET Z
        LD A,(HL)
        CALL RBRKQ
        RET C                   ;FOUND A BREAK
        INC HL
        DEC B
        INC C
        JP FLUSHW
;
RBRKQ:  CALL SIBRKQ             ;FIRST CHECK SELF INSERTING BREAKS
        RET C                   ;YES
        PUSH HL
        LD HL,BRKTBL
        LD D,NBRKS
RBRK1:  CP (HL)
        JP Z,FBRK               ;MATCH
        INC HL
        DEC D
        JP NZ,RBRK1
RBRK2:  POP HL                  ;NOT FOUND
        OR A                    ;CLEAR CARRY
        RET
;
FBRK:   POP HL
        SCF
        RET                     ;FOUND A BREAK, SET CARRY AND RETURN
;
SIBRKQ: PUSH HL
        CALL GETVOC
        LD D,(HL)               ;NUMBER OF SELF INSERTING BREAKS
        DEC D
        INC D
        JP Z,RBRK2              ;FAIL
        INC HL
        JP RBRK1
;
GETVOC: LD HL,(ZCODEP)
        LD DE,ZVOCAB
        ADD HL,DE
        LD D,(HL)
        INC HL
        LD E,(HL)
        LD HL,(ZCODEP)
        ADD HL,DE
        RET
;
BRKTBL: DB ' .,?'
        DB 0DH,0AH,9H,0CH
        DB 22H,22H
;
NBRKS   EQU $-BRKTBL
;
FINDW:  CALL GETVOC             ;FIND WORD IN VOCAB TABLE, ASSUMES VOCAB IN MEMORY
        LD A,(HL)
        INC HL
        CALL HLOFF              ;SKIP OVER SELF INSERTING BREAKS
        LD A,(HL)
        ADD A,A
        ADD A,A
        ADD A,A
        ADD A,A
        LD C,A                  ;C HAS 16 TIMES VOCAB ENTRY SIZE
        INC HL
        LD D,(HL)
        INC HL
        LD E,(HL)
        INC HL                  ;HL POINTS TO VOCAB TABLE
        LD A,(ZSTBUO+1)         ;GET FIRST CHARACTER
        LD B,A                  ;PUT IT IN B
        JP FWL2                 ;WE CAN'T START AT THE BEGINNING
;
FWL1A:  OR D                    ;HERE ON 16 WORD BOUNDRY
        JP Z,FWL3               ;END OF TABLE
FWL1:   LD A,(HL)
        CP B                    ;CHECK ONLY FIRST BYTE
        JP NC,FWL3              ;FOUND PROPER AREA FOR FINE SEARCH
FWL2:   LD A,L
        ADD A,C
        LD L,A
        LD A,H
        ADC A,0
        LD H,A                  ;POINTER TO NEXT BLOCK (HLOFF NOT USED FOR SPEED)
        LD A,E
        SUB 16                  ;16 MORE WORDS
        LD E,A
        JP Z,FWL1A
        JP NC,FWL1
        DEC D
        JP P,FWL1               ;NOT OUT OF WORDS
FWL3:   LD A,L                  ;NOW DO FINE CHECK
        SUB C                   ;BACKUP 16 WORDS
        LD L,A
        LD A,H
        SBC A,0
        LD H,A
        LD A,E
        ADD A,16
        LD E,A
        LD A,D
        ADC A,0
        LD D,A                  ;BACKUP COUNT
        LD A,C
        RRCA
        RRCA
        RRCA
        RRCA
        LD C,A                  ;REAL ENTRY SIZE
FWL4:   LD A,(ZSTBUO+1)
        CP (HL)
        JP C,FWFAIL
        JP NZ,FWL4A             ;CHECK ALL 4 BYTES
        INC HL
        LD A,(ZSTBUO)
        CP (HL)
        JP C,FWFAIL
        JP NZ,FWL4B
        INC HL
        LD A,(ZSTBUO+3)
        CP (HL)
        JP C,FWFAIL
        JP NZ,FWL4C
        INC HL
        LD A,(ZSTBUO+2)
        CP (HL)
        JP C,FWFAIL
        JP Z,FWSUCC             ;MATCH
        DEC HL
FWL4C:  DEC HL
FWL4B:  DEC HL
FWL4A:  LD A,C
        CALL HLOFF
        DEC DE
        LD A,D
        OR E
        JP NZ,FWL4              ;NOT OUT OF WORDS YET
FWFAIL: LD DE,0
        RET
;
FWSUCC: DEC HL
        DEC HL
        DEC HL
        EX DE,HL
        LD HL,(ZCODEP)
        LD A,E
        SUB L
        LD E,A
        LD A,D
        SBC A,H
        LD D,A
        RET
;
PRINTC: LD A,(ARG1)
        LD C,A
        CALL COUT
        JP MLOOP
;
PRINTN: LD HL,(ARG1)
        CALL PRNTNC
        JP MLOOP
;
PRNTNC: LD A,H
        OR A
        CALL M,PRNTNG           ;NEGATIVE NUMBER
        LD B,0                  ;DIGIT COUNT
PRNTN1: LD A,H
        OR L
        JP Z,PRNTN3
        LD DE,10
        CALL DIVIDE
        PUSH DE
        INC B
        JP PRNTN1
;
PRNTN3: XOR A
        ADD A,B
        JP Z,PRNTN6             ;PRINT AT LEAST 0
PRNTN4: POP DE
        LD A,'0'
        ADD A,E
        LD C,A
        CALL COUT
        DEC B
        JP NZ,PRNTN4
        RET
;
PRNTN6: LD C,'0'
        JP COUT
;
PRNTNG: LD C,'-'                ;PRINT -
        CALL COUT
        JP SIGNCN               ;CHANGE SIGN
;
RANDOM: LD HL,(ARG1)            ;RANDOM GENERATOR
        EX DE,HL
        CALL RND                ;GET THE BASE NUMBER
        CALL DIVIDE
        EX DE,HL                ;GET REMAINDER
        INC HL                  ;MAKE NOT EQUAL TO 0
        JP PUTVAL
;
ZPUSH:  LD HL,(ARG1)
        CALL PSHSTK
        JP MLOOP
;
ZPOP:   CALL POPSTK
        LD A,(ARG1)
        JP VARPTR
;
;**********************************************************************
;*            ZORK - RANDOM ROUTINES                                  *
;**********************************************************************
;
RND:    PUSH BC
        LD C,2                  ;2 TIMES THROUGH LOOP
RND2:   LD B,8
        LD HL,SHIFT
        LD A,(HL)
RND1:   RLCA
        RLCA
        RLCA
        XOR (HL)
        RLA
        RLA
        LD HL,SHIFT
        LD A,(HL)
        RLA
        LD (HL),A
        INC HL
        LD A,(HL)
        RLA
        LD (HL),A
        INC HL
        LD A,(HL)
        RLA
        LD (HL),A
        INC HL
        LD A,(HL)
        RLA
        LD (HL),A
        DEC B
        JP NZ,RND1
        DEC C
        JP NZ,RND2
        POP BC
        LD HL,(SHIFT+2)         ;GET THE NUMBER
        RET
;
MULT:   PUSH BC                 ;DEHL <=DE*HL
        LD BC,0
        LD A,16                 ;LOOP COUNTER
MULT1:  PUSH AF
        LD A,E
        AND 1                   ;CHECK BIT FOR ADD
        JP Z,MULT2              ;SKIP ADD PART IF 0
        PUSH HL                 ;SAVE MULTIPLIER
        ADD HL,BC               ;ADD PART
        LD B,H
        LD C,L
        POP HL                  ;RESTORE H
MULT2:  LD A,B                  ;32 BIT SHIFT REMEMBERING CARRY
        RRA
        LD B,A
        LD A,C
        RRA
        LD C,A
        LD A,D
        RRA
        LD D,A
        LD A,E
        RRA
        LD E,A
        POP AF                  ;GET BACK LOOP COUNT
        DEC A
        JP NZ,MULT1
        LD H,D                  ;PUT LOW ORDER ANSWER IN HL
        LD L,E
        LD D,B                  ;HIGH PART IN DE
        LD E,C
        POP BC
        RET
;
DIVIDE: PUSH BC                 ;HL<=HL/DE, REMAINDER IN DE
        LD B,H
        LD C,L
        LD A,D                  ;NEGATE DIVISOR
        CPL
        LD D,A
        LD A,E
        CPL
        LD E,A
        INC DE                  ;FOR TWO'S COMPLEMENT
        LD HL,0                 ;INITIAL VALUE FOR REMAINDER
        LD A,17                 ;INIT LOOP COUNTER
DDIV0:  PUSH HL                 ;SAVE REMAINDER
        ADD HL,DE               ;SUB DIVIS
        JP NC,DDIV1             ;UNDERFLOW, RESTORE HL
        EX (SP),HL
DDIV1:  POP HL
        PUSH AF                 ;SAVE LOOP COUNTER
        LD A,C                  ;4 REG SHIFT LEFT
        RLA                     ;WITH CARRY
        LD C,A                  ;CY->C->B->L->H
        LD A,B
        RLA
        LD B,A
        LD A,L
        RLA
        LD L,A
        LD A,H
        RLA
        LD H,A
        POP AF                  ;RESTORE LOOP COUNTER
        DEC A                   ;DECREMENT IT
        JP NZ,DDIV0             ;KEEP LOOPING
;
;CLEANUP, SHIFT REMAINDER RIGHT AND RETURN IN DE
        OR A
        LD A,H
        RRA
        LD D,A
        LD A,L
        RRA
        LD E,A
        LD H,B
        LD L,C
        POP BC
        RET
;
SIGNC:  XOR A
        LD (SIGNF),A            ;SET SIGNF
        CALL SIGNPC             ;POS CHECK
        EX DE,HL
        CALL SIGNPC
        EX DE,HL
        RET
;
SIGNS:  LD A,(SIGNF)            ;CHECK FOR SIGN
        AND 1                   ;EVEN OR ODD
        RET Z                   ;EVEN NUMBER OF NEGATIVES, ANSWER OK
SIGNCN: XOR A                   ;CHANGE SIGN
        SUB L
        LD L,A
        LD A,0
        SBC A,H
        LD H,A                  ;INVERTED HL
        RET
;
SIGNPC: LD A,H
        OR A
        RET P                   ;POSITIVE
        LD A,(SIGNF)
        INC A
        LD (SIGNF),A
        JP SIGNCN               ;CHANGE SIGN
;
FLAGSU: LD A,(ARG1)             ;SETUP FOR FLAG ROUTINES
        CALL OBJLOC             ;BC WILL HAVE BIT POSITION, DE FLAG VALUE
        LD A,(ARG2)             ;HL WILL GET OBJ POINTER
        CP 16
        JP C,FLGSU1             ;NEXT WORD
        SUB 16                  ;SECOND SET OF FLAGS
        INC HL
        INC HL
FLGSU1: PUSH HL
        LD B,A
        LD A,15
        SUB B
        LD HL,1
FLGSU2: JP Z,FLGSU3             ;BIT IN POSITION
        ADD HL,HL
        DEC A
        JP FLGSU2
;
FLGSU3: LD B,H
        LD C,L
        POP HL
        LD D,(HL)
        INC HL
        LD E,(HL)
        DEC HL
        RET
;
PROPB:  LD A,(ARG1)             ;BEG OF PROPERTY PART OF OBJECT
        CALL OBJLOC
        LD DE,7
        ADD HL,DE
        LD D,(HL)
        INC HL
        LD E,(HL)
        LD HL,(ZCODEP)
        ADD HL,DE
        LD A,(HL)               ;LENGTH OF DESCRIPTION
        ADD A,A                 ;*2
        INC A                   ;+1
        JP HLOFF                ;INDEX AND RETURN
;
PROPN:  LD A,(HL)               ;HL HAS REAL PROP POINTER
        AND 1FH
        RET
;
PROPL:  LD A,(HL)               ;PROP LENGTH, HL HAS REAL PROP POINTER
        RLCA
        RLCA
        RLCA
        AND 7
        RET
;
PROPNX: CALL PROPL
        ADD A,2
        JP HLOFF                ;NEXT PROP POINTER
;
OBJLOC: PUSH DE           ;GET OBJECT LOCATION, A HAS OBJECT NUMBER
        LD L,A
        LD H,0
        LD D,H
        LD E,L
        ADD HL,HL
        ADD HL,HL
        ADD HL,HL
        ADD HL,DE
        LD DE,53
        ADD HL,DE               ;9*NUMBER + 53
        PUSH HL                 ;OBJECT OFFSET
        LD HL,(ZCODEP)
        LD DE,ZOBJEC
        ADD HL,DE
        LD D,(HL)
        INC HL
        LD E,(HL)
        LD HL,(ZCODEP)
        ADD HL,DE
        POP DE
        ADD HL,DE               ;REAL ADDRESS
        POP DE
        RET
;
GETARG: LD HL,(ARG1)
        EX DE,HL
        LD HL,(ARG2)            ;GET BOTH ARGS
        RET
;
SHLGED: LD A,D
        XOR H
        JP P,HLGEDE             ;BOTH OF SAME SIGN
        LD A,H
        CP D                    ;CARRY WILL BE SET IF D NEG AND THUS LESS THAN H
        RET
;
HLGEDE: LD A,D                  ;RETURN WITH CARRY SET IF HL>=DE
        CP H
        RET NZ
        LD A,L
        CP E
        CCF
        RET
;
PSHSTK: PUSH DE
        EX DE,HL                ;PUSH STACK
        LD HL,(ZSTAKP)          ;STACK POINTER
        DEC HL
        LD (HL),E
        DEC HL
        LD (HL),D
        LD (ZSTAKP),HL          ;SAVE POINTER
        LD HL,ZSTAKC            ;COUNT
        INC (HL)
        LD A,(HL)
        CP ZSTAKL
        CALL Z,ZER
        EX DE,HL
        POP DE
        RET
;
;----------------------------------------------------------------------
;POP STACK
;----------------------------------------------------------------------
;POP WORD OFF Z-STACK AND RETURN IT IN HL
POPSTK: PUSH DE                 ;SAVE DE
        LD HL,(ZSTAKP)          ;HL <= Z-STACK POINTER
        LD D,(HL)               ;GET MSB OF WORD
        INC HL
        LD E,(HL)               ;GET LSB OF WORD
        INC HL
        LD (ZSTAKP),HL          ;SAVE NEW Z-STACK POINTER
        LD HL,ZSTAKC            ;CHECK COUNT
        DEC (HL)
        CALL Z,ZER              ;OVER POP ERROR
        EX DE,HL                ;VALUE IN HL
        POP DE                  ;RESTORE DE
        RET
;
;**********************************************************************
;*            ZORK - PAGING ROUTINES                                  *
;**********************************************************************
;
NEXTPC: LD A,(ZPCFLG)           ;HAS PAGE MOVED?
        OR A
        JP Z,NXTPC1             ;PAGE HAS MOVED
        LD HL,(ZPCPNT)
        LD B,(HL)               ;GET VALUE IN B
        INC HL
        LD (ZPCPNT),HL          ;STORE BACK POINTER
        LD HL,(ZPCL)
        INC L
        LD (ZPCL),HL            ;ASSUME OK AT FIRST
        LD A,B
        RET NZ                  ;OK IF L NOT ZERO
        LD A,H                  ;CROSSED 256 BYTE BOUNDRY
        INC H
        LD (ZPCL),HL            ;AGAIN ASSUME NOT PASSED 256 BOUNTRY
        OR A
        LD A,B
        RET Z                   ;DID NOT CROSS 512 BOUNDRY
        XOR A
        LD (ZPCL+1),A           ;0 ZPCL
        LD (ZPCFLG),A           ;BAD DATA IN PCPNT, WILL HAVE TO FETCH NEW BLOCK
        LD HL,ZPCH              ;INCREMENT ZPC HIGH
        INC (HL)
        LD A,B
        RET                     ;RETURN, TROUBLE NEXT TIME
;
NXTPC1: LD A,(ZPCH)             ;GET ZPAGE NUMBER
        LD HL,ZMEMT             ;TOP OF LOW MEM
        CP (HL)
        LD HL,(ZCODEP)          ;PRELOAD PORTION
        JP C,NXTPCL
        CALL FNDPGE
        LD (ZPCPG),A            ;STORE PAGE
        JP C,NXTPC2             ;COULD NOT FIND PAGE, SWAP IT IN (OH WHAT A SHAME)
NXTPC3: CALL SPLICE             ;PUT AT TOP OF LIST
        LD A,(ZPCPG)            ;SET UP POINTER TO PAGE
        LD HL,(PGBUFP)          ;POINTER TO BEGINNING OF PAGE BUFFERS
NXTPCL: ADD A,A
        ADD A,H
        LD H,A
        EX DE,HL                ;DE NOW HAS POINTER TO BEG OF BUFFER
        LD HL,(ZPCL)
        ADD HL,DE               ;ADD IN OFFSET
        LD (ZPCPNT),HL          ;ZPCPNT NOW VALID
        LD A,0FFH
        LD (ZPCFLG),A
        JP NEXTPC               ;TRY AGAIN, THIS TIME IT WILL NOT FAIL
;
NXTPC2: LD HL,MPCPG             ;CHECK IF DISTROYING MPC
        CP (HL)
        JP NZ,NXTPC4            ;NOT DISTROYING PAGE
        LD B,A
        XOR A
        LD (MPCFLG),A
        LD A,B
NXTPC4: LD HL,(PGBUFP)
        ADD A,A
        ADD A,H
        LD H,A                  ;POINTER TO BEGINNING OF BUFFER
        LD A,(ZPCH)
        CALL GETDSK
        LD A,(ZPCPG)
        LD B,A
        LD HL,PGTBL
        CALL HLOFF
        LD A,(ZPCH)
        LD (HL),A               ;SET PAGE TABLE ENTRY
        LD A,B
        JP NXTPC3               ;PAGE NOW IN MEMORY
;
SETWRD: LD A,H
        OR A
        RRA
        LD (MPCH),A
SETWR1: LD A,H
        AND 1
        LD H,A
        LD (MPCL),HL
        XOR A
        LD (MPCFLG),A
        RET
;
SETSTR: LD A,H
        LD (MPCH),A
        ADD HL,HL
        JP SETWR1
;
GETFRE: XOR A
        LD (MPCFLG),A           ;NO MEM PAGE LEFT
        LD A,(PGBOT)
        LD (MPCPG),A
        CALL CKZPCP
        CALL SPLICE
        LD A,(MPCPG)
        LD B,A
        LD HL,(PGBUFP)
        ADD A,A
        ADD A,H
        LD H,A
        LD (MPCPNT),HL
        LD A,B
        LD HL,PGTBL
        CALL HLOFF
        LD (HL),0
        RET
;
GETWRD: CALL GETBYT
        PUSH AF
        CALL GETBYT             ;GET A FULL WORD
        LD L,A
        POP AF
        LD H,A
        RET
;
GETBYT: LD A,(MPCFLG)           ;HAS PAGE MOVED?
        OR A
        JP Z,GETBT1             ;PAGE HAS MOVED
        LD HL,(MPCPNT)
        LD B,(HL)               ;GET VALUE IN B
        INC HL
        LD (MPCPNT),HL          ;STORE BACK POINTER
        LD HL,(MPCL)
        INC L
        LD (MPCL),HL            ;ASSUME OK AT FIRST
        LD A,B
        RET NZ                  ;OK IF L NOT ZERO
        LD A,H                  ;CROSSED 256 BYTE BOUNDRY
        INC H
        LD (MPCL),HL            ;AGAIN ASSUME NOT PASSED 256 BOUNTRY
        OR A
        LD A,B
        RET Z                   ;DID NOT CROSS 512 BOUNDRY
        XOR A
        LD (MPCL+1),A           ;0 MPCL
        LD (MPCFLG),A           ;BAD DATA IN PCPNT, WILL HAVE TO FETCH NEW BLOCK
        LD HL,MPCH              ;INCREMENT ZPC HIGH
        INC (HL)
        LD A,B
        RET                     ;RETURN, TROUBLE NEXT TIME
;
GETBT1: LD A,(VERF)
        OR A
        JP NZ,GETB1A            ;IN VERIFY MODE
        LD A,(MPCH)             ;GET MPAGE NUMBER
        LD HL,ZMEMT             ;TOP OF LOW MEM
        CP (HL)
        LD HL,(ZCODEP)          ;PRELOAD PORTION
        JP C,GETBTL
        CALL FNDPGE
        LD (MPCPG),A            ;STORE PAGE
        JP C,GETBT2             ;COULD NOT FIND PAGE, SWAP IT IN (OH WHAT A SHAME)
GETBT3: CALL SPLICE             ;PUT AT TOP OF LIST
        LD A,(MPCPG)            ;SET UP POINTER TO PAGE
        LD HL,(PGBUFP)          ;POINTER TO BEGINNING OF PAGE BUFFERS
GETBTL: ADD A,A
        ADD A,H
        LD H,A
        EX DE,HL
        LD HL,(MPCL)
        ADD HL,DE
        LD (MPCPNT),HL
        LD A,0FFH
        LD (MPCFLG),A
        JP GETBYT               ;TRY AGAIN, THIS TIME IT WILL NOT FAIL
;
CKZPCP: LD HL,ZPCPG             ;CHECK IF DISTROYING ZPC
        CP (HL)
        RET NZ                  ;NOT DISTROYING PAGE
        LD B,A
        XOR A
        LD (ZPCFLG),A
        LD A,B
        RET
;
GETB1A: LD A,(PGBOT)
        LD (MPCPG),A            ;NEW PAGE
GETBT2: CALL CKZPCP
        LD HL,(PGBUFP)
        ADD A,A
        ADD A,H
        LD H,A                  ;POINTER TO BEGINNING OF BUFFER
        LD A,(MPCH)
        CALL GETDSK
        LD A,(MPCPG)
        LD B,A
        LD HL,PGTBL
        CALL HLOFF
        LD A,(MPCH)
        LD (HL),A               ;SET PAGE TABLE ENTRY
        LD A,B
        JP GETBT3               ;PAGE NOW IN MEMORY
;
SPLICE: LD C,A                  ;SPLICE PAGE IN A TO TOP OF LIST
        LD A,(PGTOP)            ;GET OLD TOP
        CP C
        RET Z                   ;SAME TOP AS LAST
        LD B,A
        LD A,C
        LD (PGTOP),A            ;NEW TOP
        LD HL,PGTBLF
        CALL HLOFF
        LD E,(HL)               ;E HAS OLD FORWARD POINTER
        LD (HL),B               ;NEW FORWARD TO OLD TOP
        LD HL,PGTBLB
        LD A,C
        CALL HLOFF
        LD D,(HL)               ;D GETS OLD BACK POINTER
        LD (HL),0FFH            ;TOP HAS NO BACK
        LD A,D
        LD HL,PGTBLF
        CALL HLOFF
        LD (HL),E               ;PATCH FORWARD POINTER
        LD A,B
        LD HL,PGTBLB
        CALL HLOFF
        LD (HL),C
        LD A,E
        INC A
        JP Z,SPLIC1             ;WAS LAST BLOCK WITHOUT FORWARD POINTER
        LD HL,PGTBLB-1          ;OFFSET INC A
        CALL HLOFF
        LD (HL),D               ;SPLICE BACK POINTER
        RET
;
SPLIC1: LD A,D
        LD (PGBOT),A            ;NEW BOTTOM OF LIST
        RET
;
HLOFF:  ADD A,L                 ;INDIRECT HL THROUGH A
        LD L,A
        LD A,0
        ADC A,H
        LD H,A
        RET
;
FNDPGE: LD HL,NPGS              ;FIND PAGE IN A, RETURN WITH CARRY SET IF NOT FOUND
                                ;A WILL HAVE FOUND PAGE OR BOTTOM OF PAGE LIST
        LD B,(HL)
        LD C,0
        LD HL,PGTBL
FNDPGL: CP (HL)
        JP Z,FNDPG1             ;SUCCESS
        INC C
        INC HL
        DEC B
        JP NZ,FNDPGL
        LD A,(PGBOT)            ;NOT FOUND
        SCF                     ;SET CARRY AND RETURN BOTTOM
        RET
;
FNDPG1: LD A,C
        RET                     ;CARRY WILL BE CLEARED
;
;**********************************************************************
;*            ZORK - STRING ROUTINES                                  *
;**********************************************************************
;
;----------------------------------------------------------------------
;PRINT Z-STRING 
;----------------------------------------------------------------------
PZSTR:  XOR A                   ;PRINT ZSTRING POINTED TO BY MPC (NOT REENTRENT)
        LD (CSPERM),A           ;PERMANENT CHARSET
        LD (STBYTF),A           ;RESET STRING BYTE FLAG
        DEC A
        LD (CSTEMP),A           ;NO TEMP CHARSET IN EFFECT
;
PZSTRL: CALL GETZCH             ;GET A Z-CHARACTER
        RET C                   ;END OF STRING IF CARRY SET
        LD B,A
        OR A
        JP Z,PZSTRS             ;0=SPACE
        CP 4                    ;IS THIS AN F-WORD?
        JP C,PZFWRD             ;YES
        CP 6                    ;IS IT A SHIFT CHAR?
        JP C,PZSTRP             ;YES - CHANGE CHAR SET
        CALL GETMOD
        OR A                    ;IS IT CHARSET 0?
        JP NZ,PZSTR1            ;NOPE
;
;PRINT LOWER CASE CHAR (CHARSET 0)
        LD A,'a'-6              ;ASCII "a" MINUS Z-OFFSET
PZSTP0: ADD A,B                 ;ADD CHARACTER
        LD C,A
PZSTP1: CALL COUT               ;PRINT RESULT
        JP PZSTRL               ;AND FETCH ANOTHER Z-CHAR
;
;CHARSET 1 OR 2?
PZSTR1: DEC A                   ;SET 1?
        JP NZ,PZSTR2            ;NOPE, IT'S SET 2
;
;PRINT UPPER-CASE CHAR (CHARSET 1)
        LD A,'A'-6              ;ASCII "A" MINUS Z-OFFSET
        JP PZSTP0               ;PROCESS IT
;
;DECODE/PRINT CHARSET 2
PZSTR2: LD A,B                  ;MODE 2
        CP 6                    ;DIRECT ASCII CHARACTER?
        JP Z,PZSTRA             ;YES
        CP 7                    ;CARRIAGE RETURN?
        JP Z,PZSTRC             ;YES
        LD HL,CHRTBL-8          ;NO - SUBTRACT OFFSET
        CALL HLOFF
        LD C,(HL)               ;GET CHARACTER FROM TABLE
        JP PZSTP1
;
PZSTRA: CALL GETZCH             ;FORM CHARACTER FROM TWO BYTES
        RRCA
        RRCA
        RRCA
        LD C,A
        PUSH BC
        CALL GETZCH
        POP BC
        ADD A,C
        LD C,A
        CP 9                    ;TAB?
        JP NZ,PZSTP1
        LD C,20H
        JP PZSTP1               ;PRINT IT
;
PZFWRD: DEC A
        ADD A,A
        ADD A,A
        ADD A,A
        ADD A,A
        ADD A,A                 ;SET NUMBER -1 TIMES 32
        LD (FWSET),A
        CALL GETZCH             ;GET STRING NUMBER
        RET C                   ;BAD IF OUT OF CHARACTERS
        LD B,A
        LD A,(CSPERM)           ;PRINT ZSTRING POINTED TO BY MPC
        LD H,A                  ;MAKE IT REENTERENT
        LD A,(STBYTF)
        LD L,A
        PUSH HL
        LD HL,(ZSTWRD)
        PUSH HL
        LD HL,(MPCL)
        PUSH HL
        LD HL,(MPCH)
        PUSH HL
        LD HL,(FWORDS)
        LD A,(FWSET)
        ADD A,B                 ;ENTRY INTO 96 WORD TABLE
        ADD A,A
        CALL HLOFF              ;POINTER TO SPECIAL STRING
        LD A,(HL)
        LD (MPCH),A
        INC HL
        LD L,(HL)
        LD H,0
        ADD HL,HL
        LD (MPCL),HL            ;SET NEW MPC
        XOR A
        LD (MPCFLG),A           ;MPCPNT NOT VALID
        CALL PZSTR              ;PRINT SUB STRING (REENTRENT VERSION)
        XOR A                   ;RESTORE REENTRENT VALUES
        LD (MPCFLG),A
        POP HL
        LD A,L
        LD (MPCH),A
        POP HL
        LD (MPCL),HL
        POP HL
        LD (ZSTWRD),HL
        POP HL
        LD A,H
        LD (CSPERM),A
        LD A,L
        LD (STBYTF),A
        CALL GETMOD
        JP PZSTRL
;
PZSTRS: LD C,20H
        JP PZSTP1               ;PRINT SPACE
;
PZSTRC: LD C,0DH                ;CR-LF
        CALL COUT
        LD C,0AH
        JP PZSTP1
;
PZSTRT: LD A,B                  ;SET TEMP MODE
        SUB 3
        LD (CSTEMP),A
        JP PZSTRL
;
PZSTRP: CALL GETMOD             ;SET CHAR MODE
        OR A                    ;MODE 0 IS TEMPORARY
        JP Z,PZSTRT
        DEC A
        ADD A,A
        ADD A,B
        SUB 4                   ;INDEX INTO PERMTB
        PUSH HL
        LD HL,PERMTB
        CALL HLOFF
        LD A,(HL)
        POP HL
        LD (CSPERM),A
        JP PZSTRL
;
PERMTB: DB 1,0,0,2
;
CHRTBL: DB '0123456789.,!?_#'
        DB 27H,22H
        DB '/\-:()'
;
GETMOD: LD A,(CSTEMP)
        INC A
        LD A,(CSPERM)
        RET Z                   ;RETURN WITH PERM MODE IF NO TEMP MODE
        PUSH HL
        LD HL,CSTEMP
        LD A,(HL)
        LD (HL),0FFH            ;CLEAR MODE AFTER GETTING IT
        POP HL
        RET
;
GETZCH: LD A,(STBYTF)           ;FIND OUT WHICH BYTE
        OR A
        SCF
        RET M                   ;OUT OF CHARACTERS
        JP NZ,GETZH1            ;NOT FIRST BYTE
        INC A
        LD (STBYTF),A
        CALL GETWRD
        LD (ZSTWRD),HL          ;SAVE WORD
        LD A,H
        RRCA
        RRCA
        AND 1FH
        RET
;
GETZH1: DEC A
        JP NZ,GETZH2            ;LAST CHAR IN WORD
        LD A,2
        LD (STBYTF),A
        LD HL,(ZSTWRD)
        ADD HL,HL
        ADD HL,HL
        ADD HL,HL
        LD A,H
        AND 1FH
        RET
;
GETZH2: XOR A
        LD (STBYTF),A
        LD HL,(ZSTWRD)
        LD A,H
        OR A
        JP P,GETZH3             ;NOT LAST CHAR IN STRING
        LD A,0FFH
        LD (STBYTF),A           ;INDICATE END OF STRING
GETZH3: LD A,L
        AND 1FH
        RET
;
CONZST: XOR A                   ;CONVERT TO Z STRING
        LD (CSPERM),A
        LD HL,ZSTBUO            ;POINTER TO OUTPUT BUFFER
        LD B,6                  ;OUTPUT 6 CHARACTERS TO CONVERT
CONZSL: LD (HL),5
        INC HL
        DEC B
        JP NZ,CONZSL            ;FILL BUFFER WITH PAD CHARACTERS
        LD B,6
        LD DE,ZSTBUO            ;OUTPUT
        LD HL,ZSTBUI            ;INPUT
CNZSL1: LD C,(HL)
        INC HL
        LD A,C
        OR A
        LD A,5
        JP Z,CNZSLO             ;BLANKS
        LD A,C
        CP ' '
        LD A,0
        JP Z,CNZSLO             ;SPACE
CNZSL2: PUSH DE
        LD A,C
        CALL ZCHRCS             ;WHICH CHARACTER SET
        LD E,A                  ;E HAS CHARACTER SET OF CURRENT CHAR
        LD A,(CSPERM)
        CP E
        JP Z,CNZSLC             ;CONVERT THEN OUTPUT
        LD A,E
        ADD A,3
        POP DE
        LD (DE),A               ;OUTPUT TEMP SHIFT
        INC DE
        DEC B
        JP Z,CNZSLE
        PUSH DE
CNZSLC: LD A,C
        POP DE
        CALL ZCHRCS
        DEC A
        JP P,CNZSC1             ;NOT LOWER CASE
        LD A,C
        SUB 'a'-6
CNZSLO: LD (DE),A
        INC DE
        DEC B
        JP NZ,CNZSL1  ;NEXT
        JP CNZSLE ;END
;
CNZSC1: JP NZ,CNZSC3            ;NOT UPPER CASE
        LD A,C
        SUB 'A'-6
        JP CNZSLO
;
CNZSC3: LD A,C
        CP 0DH
        JP NZ,CNZSC4
        LD A,(HL)
        CP 0AH
        JP NZ,CNZSC4
        INC HL
        LD A,7
        JP CNZSLO               ;CR-LF
;
CNZSC4: LD A,C
        CALL CNZS2M
        JP NZ,CNZSLO            ;FOUND IN TABLE
        LD A,6
        LD (DE),A
        INC DE
        DEC B
        JP Z,CNZSLE             ;STORE ASCII VERSION
        LD A,C
        RLCA
        RLCA
        RLCA
        AND 3
        LD (DE),A
        INC DE
        DEC B
        JP Z,CNZSLE
        LD A,C
        AND 1FH
        JP CNZSLO
;
CNZS2M: PUSH BC
        PUSH HL
        LD HL,CHRTBL+23         ;SEARCH TABLE
        LD B,24
CNZS2L: CP (HL)
        JP Z,CNZS2P             ;FOUND
        DEC HL
        DEC B
        JP NZ,CNZS2L
        POP HL                  ;NOT FOUND
        POP BC
        RET                     ;FAIL, ZERO SET
;
CNZS2P: LD A,B
        ADD A,7
        POP HL
        POP BC
        RET                     ;PASSED, ZERO CLEARED
;
ZCHRCS: CP 'a'
        JP C,ZCHRC1
        CP 'z'+1
        JP NC,ZCHRC1
        XOR A
        RET                     ;SET 0
;
ZCHRC1: CP 'A'
        JP C,ZCHRC2
        CP 'Z'+1
        JP NC,ZCHRC2
        LD A,1
        RET
;
ZCHRC2: OR A
        RET Z
        RET M                   ;END
        LD A,2
        RET                     ;ELSE SET 2
;
CNZSLE: LD BC,ZSTBUO            ;CONVERT OUTPUT STRING
        LD HL,0
        LD D,H
        CALL CNZSE1
        CALL CNZSE1
        CALL CNZSE1
        LD (ZSTBUO),HL
        LD HL,1
        CALL CNZSE1
        CALL CNZSE1
        CALL CNZSE1
        LD (ZSTBUO+2),HL
        RET
;
CNZSE1: LD A,(BC)
        INC BC
        LD E,A
        ADD HL,HL
        ADD HL,HL
        ADD HL,HL
        ADD HL,HL
        ADD HL,HL
        ADD HL,DE
        RET
;
;**********************************************************************
;*            ZORK - DATA SECTION                                     *
;**********************************************************************
;
SRND:                     ;RANDOM INFO FOR SAVE, KEEP TOGETHER
LOCALS: DS 15*2           ;STORAGE FOR LOCALS
ZPCH:   DB 0              ;HIGH ORDER 8 BITS OF ZPC
ZPCL:   DW 0              ;LOW ORDER 9 BITS OF ZPC
ZSTAKC: DB 1              ;STACK COUNT, 1=>0 IMPLIES OVERPOP, NEG=> OVER PUSH
OZSTKP: DW 0              ;OLD ZSTACK POINTER
OZSTKC: DB 0              ;OLD ZSTACK COUNT
;
SHIFT:  DB 6AH,57H,3CH,99H
SRNDC   EQU $-SRND
ZSTBUI: DS 6              ;ZSTR INPUT BUFFER
        DB 0FFH           ;END MARKER
NOLPT:  DB 1              ;NON ZERO IMPLIES DO NOT USE LPT
VERF:   DB 0              ;1 IF IN VERIFY MODE
ZMEMT:  DB 1              ;FIRST PAGE IN SWAPPING SPACE
;
PURSTP:                   ;END OF PURE
;
SIGNF:  DB 0              ;STORAGE FOR SIGN IN MULT AND DIVIDE
ARG1:   DW 0              ;OPERRAND 1
ARG2:   DW 0              ;" 2
ARG3:   DW 0              ;" 3
ARG4:   DW 0              ;" 4
ARGCNT: DB 0              ;ARG COUNT
OPCODE: DB 0              ;CURRENT OPCODE
GLOBAL: DW 0              ;POINTER TO GLOBAL 0
FWSET:  DB 0              ;TEMPORARY STORAGE FOR FWORDS CALCULATION
FWORDS: DW 0              ;COMMON WORDS POINTER
ZPCOFF: DW 0              ;OFFSET FOR FAST JUMPS
ZPCPNT: DW 0              ;REAL POINTER TO PC
ZPCFLG: DB 0              ;0FFH IF VALID PC POINTER
ZPCPG:  DB 0              ;PAGE OF ZPC
MPCH:   DB 0              ;HIGH ORDER 8 BITS OF MEMORY POINTER
MPCL:   DW 0              ;LOW ORDER 9 BITS OF MEMPOINTER
MPCPNT: DW 0              ;REAL POINTER TO MEMORY LOCATION
MPCFLG: DB 0              ;0FF IF VALID MPCPNT
MPCPG:  DB 0              ;PAGE NUMBER OF PC PAGE
;
;PAGE TABLES
PGBUFP: DW 0              ;BUFFER POINTER
ZCODEP: DW 0              ;LOW MEM STARTING POINTER
;
NPGS:   DB 0              ;NUMBER OF PAGES
PGTOP:  DB 0              ;TOP OF LIST PAGE
PGBOT:  DB MAXPGS-1       ;BOTTOM OF LIST
;
CSTEMP: DB 0              ;-1 IF NOT TEMP CHAR SET, ELSE SET
CSPERM: DB 0              ;PERM CHARACTER SET
STBYTF: DB 0              ;0 FOR FIRST BYTE, 1 FOR 2, 2 FOR 3, 0FFH FOR END
ZSTWRD: DW 0              ;WORD STORRAGE
ZSTBUO: DS 6              ;OUTPUT BUFFER
RTABP:  DW 0              ;TEMP FOR ZREAD, RESULT TABLE POINTER
;
LMEMRY: DW 0              ;LAST LOCATION IN MEMORY, FILLED IN BY LOADER
;
        END START
;
;
;EOF
